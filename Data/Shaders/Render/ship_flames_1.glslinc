###VERTEX

#version 120
#extension GL_ARB_draw_instanced : enable

#define in attribute
#define out varying

// Inputs
in vec4 inFlame1; // Position, PlaneId, FlamePersonalitySeed
in vec2 inFlame2; // FlameSpacePosition

// Outputs
out float flamePersonalitySeed;
out vec2 flameSpacePosition;
out float noBorder;

// Params
uniform mat4 paramOrthoMatrix;

void main()
{
    flamePersonalitySeed = inFlame1.w;
    flameSpacePosition = inFlame2.xy;
    noBorder = float(gl_InstanceIDARB);

    gl_Position = paramOrthoMatrix * vec4(inFlame1.xyz, 1.0);
}

###FRAGMENT

#version 120

#define in varying

// Inputs from previous shader
in float flamePersonalitySeed; // [0.0, 1.0]
in vec2 flameSpacePosition; // (x=[-0.5, 0.5], y=[0.0, 1.0])
in float noBorder;

// The texture
uniform sampler2D paramNoiseTexture1;

// Params
uniform float paramTime;
uniform float paramWindSpeedMagnitude;

//
// Based on "Flame in the Wind" by kuvkar (https://www.shadertoy.com/view/4tXXRn)
//

float GetNoise(vec2 uv) // -> (0.25, 0.75)
{
    return texture2D(paramNoiseTexture1, uv).r * 0.5 + 0.25;
}

mat2 GetRotationMatrix(float angle)
{
    mat2 m;
    m[0][0] = cos(angle); m[0][1] = -sin(angle);
    m[1][0] = sin(angle); m[1][1] = cos(angle);

    return m;
}

// -----------------------------------------------
void main()
{    
    vec2 uv = flameSpacePosition - vec2(0.0, 0.5); // (x=[-0.5, 0.5], y=[-0.5, 0.5])
    
    //
    // Flame time
    //

    #define FlameSpeed 0.345
    float flameTime = paramTime * FlameSpeed;

    
    //
    // Apply wind
    //
    
    // Rotation angle
    float windAngle = -sign(paramWindSpeedMagnitude) * 0.8 * smoothstep(0.0, 100.0, abs(paramWindSpeedMagnitude));
    
    // Rotation angle is higher the higher we go
    windAngle *= flameSpacePosition.y;    
            
    // Rotate around bottom
    uv = GetRotationMatrix(windAngle) * (uv + vec2(0.0, 0.5)) - vec2(0.0, 0.5);


    //
    // Get noise for this fragment and time
    //

    #define NoiseResolution 0.6
    float fragmentNoise = GetNoise(uv * NoiseResolution + vec2(flamePersonalitySeed) + vec2(0.0, -flameTime));
    
    
    //
    // Rotate fragment based on noise and vertical extent
    //
    
    float angle = (fragmentNoise - 0.5);
        
    // Magnify rotation amount based on distance from center of screen
    angle /= max(0.1, length(uv));
        
    // Straighten the flame at the bottom and make full turbulence higher up
    angle *= smoothstep(-0.8, 0.5, flameSpacePosition.y);    
    
    // Smooth the angle
    angle *= 0.45;
    
    // Rotate!
    uv += GetRotationMatrix(angle) * uv;    
        
    
    //
    // Calculate thickness
    //

    #define FlameWidth 1.4 // The higher, the narrower
    float thickness = 1.3 - abs(uv.x) * FlameWidth;
    
    // Taper flame depending on randomized height
    float variationH = fragmentNoise * 1.5;
    thickness *= smoothstep(1.3, variationH * 0.5, flameSpacePosition.y); // Taper up
    thickness *= smoothstep(-0.15, 0.15, flameSpacePosition.y); // Taper down    
    
    // Cut flame
    thickness = clamp(thickness, 0.0, 3.0);

    // Focus (less halo, larger body)
    #define FlameFocus 3.0
    float focusedThickness = pow(thickness, FlameFocus);

    
    //
    // Emit
    //
	        
    if (focusedThickness < 0.25) // thickness=0.62
        discard;

    // Core1 (white->yellow)
    vec3 col1 = mix(vec3(1.0, 0.764, 0.1), vec3(1.0, 1.0, 1.0), smoothstep(0.8, 1.5, thickness));

    // Core2 (->red)
    col1 = mix(vec3(1.0, 0.35, 0.0), col1, smoothstep(0.72, 1.6, thickness));

    // Border (->dark red)
    col1 = mix(vec3(0.3, 0.0, 0.0), col1, smoothstep(0.2, 0.6, focusedThickness) + noBorder);
    
    // Blend with background
    // When no border: transparent < 0.7  --- opaque > 1.2
    // When border:    transparent < 0.0 --- opaque > 0.5
    float alpha = smoothstep(0.0 + noBorder*0.7, 0.5 + noBorder*0.7, thickness);
    
    gl_FragColor = vec4(col1, alpha);
}