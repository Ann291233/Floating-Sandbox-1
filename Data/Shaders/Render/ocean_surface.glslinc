#undef RENDER_ALL_PLANES // TODO
vec4 CalculateOceanPlaneColor(
    vec4 baseColor, 
    float yWorld, 
    float yBackWorld, float d2YBackWorld,
    float yMidWorld, float d2YMidWorld,
    float yFrontWorld, float d2YFrontWorld)
{
    //
    // Calculate border width
    //
    
    float dWorld = dFdy(yWorld); // World per pixel
    float basalBorderWidth = 1.5 * dWorld; // pixels

#ifdef RENDER_ALL_PLANES
    // TODO
    float borderWidthHalfBack = basalBorderWidth + abs(dFdx(yBackWorld));
    float borderWidthHalfMid = basalBorderWidth + abs(dFdx(yMidWorld));
#endif

    float borderWidthHalfFront = basalBorderWidth + abs(dFdx(yFrontWorld)) * 1.2;

    //float df = dFdx(yFrontWorld) / dWorld;
    //borderWidthHalfFront = basalBorderWidth * sqrt(1. + df * df);

    // TODOHERE: remember that we start drawing from yFrontWorld
    float TODOoffset = 40. * dWorld;
    float yFrontMidBorder = yFrontWorld - TODOoffset + borderWidthHalfFront * d2YFrontWorld / (dWorld * 70.);

    //
    // Color
    //

    // 1 when yWorld is below middle of the border, 0 otherwise

#ifdef RENDER_ALL_PLANES
    float baseColorBack = step(yWorld, yBackWorld - borderWidthHalfBack);
    float baseColorMid = step(yWorld, yMidWorld - borderWidthHalfMid);
#endif

    float baseColorFront = step(yWorld, yFrontMidBorder);

#ifdef RENDER_ALL_PLANES
    float baseColorAlpha =
        max(
            1. * baseColorFront,
            max(
                .6 * baseColorMid,
                .5 * baseColorBack));
#else
    float baseColorAlpha = 1. * baseColorFront;
#endif

    //return vec4(baseColor, baseColorAlpha);

    //
    // Border
    //

#ifdef RENDER_ALL_PLANES
    float borderBack =
        1. - smoothstep(0., borderWidthHalfBack, abs(yWorld - (yBackWorld - borderWidthHalfBack)));

    float borderMid =
        1. - smoothstep(0., borderWidthHalfMid, abs(yWorld - (yMidWorld - borderWidthHalfMid)));
#endif

    float borderFront =
        1. - smoothstep(0., borderWidthHalfFront, abs(yWorld - yFrontMidBorder));

#ifdef RENDER_ALL_PLANES
    // epsilon when front is visible, 1 otherwise
    #define FrontObscuredAlpha 0.4
    float borderFrontOpaqueness = (1. - baseColorFront) * (1. - FrontObscuredAlpha) + FrontObscuredAlpha;

    // epsilon when mid is visible, 1 otherwise
    #define MidObscuredAlpha 0.4
    float borderMidOpaqueness = (1. - baseColorMid) * (1. - MidObscuredAlpha) + MidObscuredAlpha;
#endif

#ifdef RENDER_ALL_PLANES
    float borderAlpha =
        max(
            1. * borderFront,
            max(
                .9 * borderMid * borderFrontOpaqueness,
                .7 * borderBack * borderFrontOpaqueness * borderMidOpaqueness));
#else
    float borderAlpha = 1. * borderFront;
#endif

    //return vec4(1., 1., 1., borderAlpha);

    // Combine

    vec4 finalColor = mix(
        vec4(baseColor.xyz, baseColorAlpha * baseColor.w),
        vec4(1.), // Border color
        borderAlpha);

    // TODOTEST
    finalColor = vec4(1., 1., 1., borderAlpha);

    //return finalColor * .5 + vec4(vec3(frontDeriv), 1.) * .5;
    return finalColor;
}
