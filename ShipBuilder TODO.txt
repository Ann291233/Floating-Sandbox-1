- Gist:
	- Code organization:
		- ShipBuilderLib project, slave of FloatingSandbox project
		- ShipBuilder project, top-level project for standalone SB UI
			- For testing ShipBuilder alone
			- Just MainApp basically
		- All in separate ShipBuilder namespace
	- Own frame for UI
	- Model, View, Controller architecture
	- Reuses existing ResourceHelper, only need (at this moment) for separate resource directory and method is Shaders ("Game" and "ShipBuilder")
	- On the "structure: pixels vs triangles", Wreno says fine to edit in pixel mode, and allow user to eventually _view_ also in triangle mode (but not necessarily edit)
	- On the size: Wreno says "no fixed sized, allow whole world"

- Architecture:
	- Main Frame, toolboxes, etc.
		- Very thin, calls into Controller for each interaction
	- Controller
		- Main Frame calls into Controller for each user interaction
			- TODO: Controller->Main Frame callbacks? Via something like "IMainFrame" (TODO: better name)
		- Maintains interaction state
		- Maintains Undo stack
		- Modifies Model
	- Model
		- All data, almost no operations
		- Modified by Controller
	- View
		- Rendering of ship, all layers
		- Fully OpenGL

- MainFrame:
	- Created by game MainFrame at initialization, but kept hidden
		- Via ShipBuilder::MainFrame::Create(IProgress, ...)
	- Inherits FullScreen state and shares state changes (so, for example, if exits full screen in ShipBuilder, also Game has exited full screen)
		- How to share state changes? 
			- FullScreenManager class, shared_ptr in both
	- Switching between two frames: 
		- MainFrame owns ShipBulderFrame, ShipBulderFrame takes std::function(std::optional<...ship file path...>) "ReturnToGame" in cctor
			- Latter may be null for stand-alone test executable
		- Switch implemented via:
			- MainFrame::SwitchToShipBuilder: invoked by MainFrame when user switches to ship builder
				- Stops game loop
					- Ideally not just "pause", but full "stop"
						- GameController::Stop(), resumed only via call that takes ship
							- Same mechanism also becomes used by ::MainFrame
				- Hides self
				- Invokes ShipBuilder::MainFrame::Open(...ship file path...)
			- ShipBuilder::MainFrame::ReturnToGame: invoked by ShipBuilder::MainFrame when user returns to game
				- Hides self
				- Invokes std::function(std::optional<...ship file path...>) "ReturnToGame"
	- Impl:
		- Create(opengl initialization canvas, IProgress)
		- Open(...ship file path...)
		- TODOHERE
	- Misc:
		- Open(...) must set openGL context current on own canvas at first show (first show of entire process lifetime, no need to set it each time we're shown)
		- Panning is via "losse" scrollbars around canvas
			- Their range & properties (& position==thumb) need to be updated at:
				- glCanvas resize
				- Zoom changes
				- Pan changes
				- WorkCanvas resize (i.e. image resize)
			- Try to make it so that if scrollbars really end up disappearing, we don't resize the glCanvas

- RenderContext:
	- Single-threaded
	- Initializes on same canvas that main frame initializes on
		- So needs to be passed to SB::MainFrame's cctor
		- TODO: after or before? Better before for less chance of side effects?
			- Ideally other context is removed before new one is set
			- See if can move global GameOpenGL initialization outside of Game RenderContext and into ::MainFrame initialization, before both
	- Renders synchrnously, on-demand via SB::MainFrame::OnPaint()
	- ViewModel:
		- Terminology:
			- WorkCanvas: has the pixel size of the structure (equivalent of ::World)
			- WorkCoordinates (type @ ShipBuilderTypes)
			- DisplayLogicalCanvas: has the logical display (window) size (equivalent of ::Logical)
			- DisplayLogicalCoordinates: the logical display coordinates (type @ ShipBuilderTypes)
			- DisplayPixelCanvas: has the pixel display (window) size (equivalent of ::Pixel)
			- DisplayPixelCoordinates: the pixel display coordinates (type @ ShipBuilderTypes)
		- Knows about work area (i.e. structure) size, for panning calculations
		- World coords is model pixel coords
		- Tells outside world of pan extent (for scrollbar width setting)
			- Based on calc'd pixel (display) coords of four sides of work area

- UI architecture:
	- Topmost toolbar:
	- Above main working area: "tab-like" buttons for layers, including "+" to add layers, and horizontal sliding bar for transparency of currently-selected layer
		- Or as Wreno: 1 slider + N checkboxes for the "other layers" to see on top of currently-edited layer, with that transparency
	- Left toolbar: tools:
		- Changes content depending on currently-selected layer
		- Structure layer:
			- Pencil
			- Mass changer
	- Main work area: glCanvas with "losse" scroll bars

- Controls:
	- BitmapCheckbox (see if * exists) (@UIControls)
		! We'll re-use it for ShipLoadDialog
	- PopupButton (@UIControls)
		! We'll use it for popup tools
		- Takes callback for push, which takes wxPoint
	- MaterialsPalette (@ShipBuilder)
		- TODO: in which project does this one go? It's not a common control, yet we don't want to create a separate ShipBuilderUIControls project?
		- Column 1: scrollable vertical panel with bitmap button for selecting category
		- Column 2: scrollable panel with rows and cols for selected category's materials
		- Materials/DB changes:
			- For each category, must have one selected as the "header" (shown in column 1)
			- TODO: see if can keep rows and cols, or refactor it - we still want to be able to generate template image
		- Opened on demand when clicking on Foreground (or "TODO1") and Background (or "TODO2") PopupButtons, taking material as argument
			- And then sets focus on it

- Ship file format:
	- Min FS version (.shp, .shp2)
		- Ideally it should be a "set" of versions, including the Materials' DB versions which live in the json so to be easily editable manually
	- "File lock" which disallows editing
		- Password from user -> Hash in file
	- Also includes sounds
		- Extract from other "TODO" .txt file

- Misc:
	- Ruler: pick a scale (pixels to meter of original ship), then you choose how long the ruler
		- L shaped: horizontal and vertical
		- Ruler sticks to the canvas
		- Only one ruler at a time
	- Texture Generator for ship canvas:
		- Makes larger image, with bilinear interpolation with alpha blending
			- Ain't that what we've got already for the auto-texturizer?
	- Selectable backgrounds

