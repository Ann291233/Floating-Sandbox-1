https://gamejolt.com/x/permalink/comment/11457002

+ Move/merge integral coords/size from shipbuilder to game
	+ Game: "ShipSpace" and "DisplayPhysical/Logical"		
	+ ShipBuilder

+ SB::ViewModel: ortho matrix: see again why ShipSpace says positive bottom
	+ Anchor to the top

+ LayerBuffer.h: "layer buffer" types
	+ StructuralLayerBuffer == Buffer2D<StructuralElement, ShipSpace>
		+ StructuralElement = <StructuralMaterial*>
	+ ElectricalLayerBuffer == Buffer2D<ElectricalElement, ShipSpace>
		+ ElectricalMaterial = <ElectricalMaterial*, instance ID>
	+ RopesLayerBuffer == Buffer2D<RopeElement, ShipSpace>
		+ RopeElement = <StructuralMaterial*, endpoint ID>
	+ TextureLayerBuffer == Buffer2D<rgbaColor, ImageSpace>

+ Use "layer buffers" at ShipFactory
	+ ShipMaterialization class (@GameLib): four buffers
	+ static ShipFactory::MaterializeShip(...) -> ShipMaterialization
		+ See first if can make whole ShipFactory static again
		+ Also includes filling-in Ropes from rope endpoints found in structure (legacy)
			+ Throw on conflicts, like (should be) now
		+ Also includes filling-in Electrical from electrical materials found in structure (legacy)
			+ Throw on conflicts, like (should be) now
	+ ShipFactory::WhateverNow(): use MaterializeShip to get ShipMaterialization and continue from there
		+ Given that you're at it: ShipFactoryTypes::ShipFactoryPoint: nuke vec2i and replace with ShipSpaceCoordinates (and user-facing coords being ImageCoordinates)
	+ Test:
		+ Basic:
			+ Legacy ropes
			+ Native ropes
			X Legacy+Native ropes
			+ Legacy electrical
			+ Native electrical
			X Legacy+Native electrical
			+ Texture
		+ Corner cases:
			+ Ropes: too many endpoints for same Rope ID
				+ All legacy
				+ All native
		+ Both auto-texturization settings
		+ Perf (before & after)
			+ Before: ~100ms (factory including auto-text)
			+ After: ~110ms

+ Check if also old code asserted on Szerszen cargo for hull

= Ship De/Serialization
	! Spec:
		- Ultimate ship definition consists of LayerBuffers, not images (except for Texture obviously)
		- ShipMaterialization functionality currently in ShipFactory should move to ship deserializer, for formats "png" and "shp"
			- This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
	= Impl:
		+ ShipMaterialization also carries all attributes of ShipDefinition
		= ShipDeserializer
			= Load(filepath, MaterialDB) -> ShipMaterialization
				+ ShipMaterialization functionality currently in ShipFactory should move to ship deserializer, for formats "png" and "shp"
					+ This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
				= png
				= shp
			- LoadPreview(filepath, MaterialDB) -> ShipPreview
				- png
				- shp
			- Save(ShipMaterialization, filepath)
				- NOP at the moment
		- Also add ShipPreview functionality to ShipDeSerializer
			- See exactly how it's used
		- Nuke ShipDefinition, ShipDefinitionFile
		- "ShipMaterialization" -> "ShipDefinition"
		- Use ShipDeSerializer		
		- ShipFactory:
			- Nuke MaterializeShip code, just begin with ShipMaterialization as arg

- Model contains the four new layer buffer types (as uq_ptr)

- Merge into shipbuilder

----------------------

- Undo hierarchy: there are four subtypes of UndoEditAction - for each of the "layer buffer" types - on top of e.g. "resize" and "all layers"
	- These four are all implemented via a single templated class, templated on TLayerBuffer
	- Apply() invokes Controller::RestoreLayer(TLayerBuffer const &, origin)

- Click-And-Draw use case:
	- Pencil tool (*)
		+ UndoStack.h/cpp, w/IUndoEntry interface w/UndoEntryType enum
		+ Controller: forward mouse events to tool
		+ View:
			+ Upload method for texture *region*
		= EditAction for it
			- Undo: only baked and added at mouse up, containing whole affected region
				- Spec:
					- Tool makes clone of entire region at mouse down
					- At each pixel edit, tool updates region's origin and size
					- At mouse up, tool makes UndoEntry with clone of material region 
				- Impl:
					- Pencil tool stays templated on LayerType
					- Tool has std::opt<InteractionState> with AABBi (TODO: or new class) and clone of entire region
						- LayerTypeTraits<LayerType> gives type of LayerBuffer
					- At mouse down: capture mouse
					- At mouse up, tool makes UndoEntry with clone of material region 
						- Model::CloneStructuralLayer() -> StructuralLayerBuffer
							- Buffer2D: has method to be "regionized" (restricted)
							- ModelController::RestoreStructuralLayer(StructuralLayerBuffer)
						- Then release mouse
						- The set Model::StructuralLayer as dirty
					- Restored via ModelController::RestoreStructuralLayer(StructuralLayerBuffer)
				- ModelController::XXXRegionFill does not return UndoEntry anymore
		- Hook UndoEntry to UndoStack
		- Undo stack: owned by Controller, given to Tool
			- Tool's action writes into UndoStack and invokes IUserInterface notification
			- IUserInterface notification: Undo and Redo menu items
			- MainFrame: on Undo/Redo, call into Controller::TODO:undo/redo
			- Controller::TODO:undo/redo
		- UndoEntry exposes:
			- string GetTitle()
			- std::uint64_t GetCost()
			- void Undo(Controller &)
				- Double-dispatch: invokes Controller::method_for_region_or_resize, with isLast flag for view update
			- void Redo(Controller &)		
	- Line tool
		- Previews (*)
	- Eraser tool
	- Strategy for other tools' enums - to make it work for now

- Load Ship
	- ShipFactory: static helper: file-> "Todo" == matrices of information (Structural:material*, Electrical:material* + instanceId, Ropes:TODO, Texture:rgbaColor)
	- MainFrame::LoadShip -> Definition -> pass definition to ModelController (via Controller) -> ShipFactory's static helper -> "TODO" -> own matrices

- Previews:
	- Spec:
		- Tools like line, square, paste, translate, etc. draw a preview of how the Model looks like if the tool is "confirmed"
		- Workflow is:
			- Left down: start
			- Move: each movement shows "as if" it were confirmed there
			- One of these:
				- Confirm: same as last shown
				- Abort (ESC): back to original
	- Impl:
		- TODOHERE

- Controller/Tools/WorkSpace/Mouse canvas strategy:
	- Spec:
		- When mouse is not down, cursor changes depending on whether or not mouse is inside rect
		- At left down, tool "captures mouse" and from that moment:
			- Cursor stays even when mouse is out (while normally, when left is not down, cursor would change to normal)
			- Action is done, but only *applied* if in rect (obviously) 
				- e.g. pencil: simply doesn't write if out (obviously)
				- e.g. line: line endpoint follows mouse even if out, but line drawn is only within rect (obviously)
		- Should also take care of functionality current in pencil tool, i.e. checking if mouse position is within rect, and
		  transforming mouse coords into work space coords
	- Impl:
		- TODOHERE

- Resize workflow:
	- Button - in File panel, slightly separated from the File buttons
	- Click -> Dialog for Canvas Centering/Clipping -> Controller -> ...TODO...
	- TODO: should we move the "X-and-back-to-game" buttons to the File panel as well, nuking that rightmost panel?

- Grid view:
	- TODO: where is the toggle button? Need new top panel area? Re-design top panel area?

- Undo stack visualization: underneath toolbar?

- Materials palette:
	- Material descriptions
		- json + Material class
			- TODO: what to do with localization?
		- Text area underneath property grid
			- Methods: "SetMaterialProperties" instead of "SetMaterialPropertyGrid"			
			
- App icons (whole "Resources" folder)

================================================================================================================================================================================

- Gist:
	- Code organization:
		- ShipBuilderLib project, slave of FloatingSandbox project
		- ShipBuilder project, top-level project for standalone SB UI
			- For testing ShipBuilder alone
			- Just MainApp basically
		- All in separate ShipBuilder namespace
	- Own frame for UI
	- Model, View, Controller architecture
	- Reuses existing ResourceHelper, only need (at this moment) for separate resource directory and method is Shaders ("Game" and "ShipBuilder")
	- On the "structure: pixels vs triangles", Wreno says fine to edit in pixel mode, and allow user to eventually _view_ also in triangle mode (but not necessarily edit)
	- On the size: Wreno says "no fixed sized, allow whole world"

- Architecture:

	- MainFrame: IUserInterface
	  |------------------------------>View
	  |-------> Controller/Tools		    
		    |---->ModelController
			  |---->Model
			  |------------------------>View

	- MainFrame: owns toolboxes, etc.
		- Owns Controller and View
		- Very thin, calls into Controller for each high-level interaction (e.g. SelectTool(.), OnWorkbenchStateChanged(.))
		- Implements IUserInterface with interface required by controller, e.g. UI state changes, mouse capture, undo stack visualization
		- Owns WorkbenchState
			- Candidate for saved settings
			- Contains foreground and background materials, and settings for all tools
		- Implements ship load/save logic, giving/getting whole ShipDefinition to/from ModelController
	- Controller
		- Owns ModelController, takes reference to View
		- Main Frame calls into Controller for each user interaction, including button clicks
			- Controller->Main Frame callbacks via IUserInterface
		- Maintains UI state (e.g. grid toggle, visible layers), instructing View
		- Maintains Undo stack (not individual entries), and orchestrates undo stack visualization with IUserInterface
		- Maintains interaction state, implemented via Tools
		- Owns SelectionManager pseudo-tool
		- Owns ClipboardManager pseudo-tool
	- ModelController
		- Owns Model, takes reference to View
		- Implements all interactions and algorithms (e.g. pencil, line, flood, paste, etc.), uploading resulting changes from Model into View,
		  and creating Undo stack entries		
	- Model
		- All data, (almost) no operations (anemic), fully exported
		- Modified by ModelController
		- Knows nothing about view
		- IsDirty tracking
	- View
		- Rendering of ship, all layers
		- Rendering of tool interactions (e.g. marching ants, squares, etc.)
		- Fully OpenGL
	- Tools
		- "Extensions" of Controller
		- Implement state machines for interactions, including visual notifications (marching ants, paste mask, etc.)
		- Take references to WorkbenchState (at tool initialization time)
		- Selection tool Take references to SelectionManager (at tool initialization time), so that it can save selection to it
		- Receive input state events from Controller, and notifications of WorkbenchState changed
		- Take references to View and ModelController
		- Modify Model via ModelController
		- Instruct View for tool interactions, e.g. tool visualizations (lines, paste mask, etc.)
		- Have also reference to IUserInterface, e.g. to capture/release mouse

----------------------------------------------------------------------------------------------------------

- Workflows:
	- Create New Ship (@menu, @file panel)
		- GameController::CreateNew()
	- Create New Ship From TExture (@menu, @file panel)
		- GameController::CreateNewFromTexture()
	- Load Ship (@menu, @file panel)
		- GameController::Load()

- UI Controls:
	+ Button to save and go back to game (!StandaloneMode)
	+ Button to quit and go back to game (!StandaloneMode)
	- Button to Save (acts also as SaveAs for first save; menu however has also separate SaveAs)
	- Undo stack
	- Error (message) notification(s)
	+ Add electrical/texture/ropes layer
	- Button to open ShipMetadata dialog
	- Resize button (canvas resize)


- StatusBar:
	- Own class
	- Areas:
		- Canvas:
			- Coords and icon
			- Selection size and icon
			- WorkSpace size and icon
			- Material under cursor (for ?)
		- Ship: (i.e. ship measurements) 
			- Need UnitsSystem in Preferences
			- Coords and icon
			- Ship size and icon

- Tools:
	! Most tools should pan when the (captured) mouse is outside of the canvas
		- Via BaseTool::ScrollIntoViewIfNeeded, which simply forwards to IUserInterface::ScrollIntoViewIfNeeded(display logical)
	+ Tool:
		+ Stores all protected references passed from cctors: IUserInterface, ModelController, View
		+ Same abstract methods from game - but all pure
	- All tools:
		= Pencil
			- Settings: Size
		- Eraser
			- Settings: Size
		- Flood
		- Selection
			- Implements selection interaction and rendering of visual feedback *during the interaction only*
			- Takes SelectionManager ref in its cctor, and populates it upon confirmation of selection made
		- Sample
		- Line
		- Rectangle
			- Settings: FillWithFore|FillWithBack|NoFill; Size
		- Ellipses
		- Translate
		- Mass changer
	- SelectionManager pseudo-tool:
		- Maintains current selection
		- Not really a tool but a pseudo-tool
		- Takes View so that it can instruct it to render marching ants
			- Is not responsible for drawing of temporary selection while the user is making it, that is the Selection tool
		- Read by ClipboardManager pseudo-tool to make clip
		- TODO: templated on layer type?
	- ClipboardManager pseudo-tool:
		- Maintains clip
		- Implements operations: Copy, Cut, Paste
			- TODO: who should be responsible for the interactions during Paste? See Photoshop and Paint
				- A different, unselectable tool?
		- Talks with IUserInterface to enable/disable menus

- RenderContext:
	- Single-threaded
	- Initializes on same canvas that main frame initializes on
		- So needs to be passed to SB::MainFrame's cctor
		- TODO: after or before? Better before for less chance of side effects?
			- Ideally other context is removed before new one is set
			- See if can move global GameOpenGL initialization outside of Game RenderContext and into ::MainFrame initialization, before both
	- Renders synchronously, on-demand via SB::MainFrame::OnPaint()
		- Except when we need animated tools, e.g. ants walking: for these we set a timer (in the order of 100's of ms) during the duration
		  of the tool
			- via an IUserInterface method, and another call to stop it ("SetAutoRender(bool)")
	+ ViewModel:
		+ Terminology:
			+ WorkSpace: has the pixel size of the structure (equivalent of ::World)
			+ WorkSpaceCoordinates (type @ ShipBuilderTypes)
			+ DisplayLogical: has the logical display (window) size (equivalent of ::Logical)
			+ DisplayLogicalCoordinates: the logical display coordinates (type @ ShipBuilderTypes)
			+ DisplayPixel: has the pixel display (window) size (equivalent of ::Pixel)
			+ DisplayPixelCoordinates: the pixel display coordinates (type @ ShipBuilderTypes)
		+ World coords is model pixel coords, i.e. WorkSpace
		+ Tells outside world of pan extent (for scrollbar width setting)
	- Primitives:
		+ Background text
		+ Structural RenderColor Texture
		- Electrical RenderColor Texture
		- Pseudo-cursor
			- One of many types; removed with a single call


- WorkbenchState
	+ Independent from model - exclusively tools-related settings
		+ So no need to reset/change/update at new model creation
	= cctor: (MaterialsDB, SB::PreferencesManager)
		+ FW and BG materials: always "defaults" from MaterialsDB
		- other settings: loaded from SB::PreferencesManager

- Ship file format:
	- Min FS version (.shp, .shp2)
		- Ideally it should be a "set" of versions, including the Materials' DB versions which live in the json so to be easily editable manually
	- "File lock" which disallows editing
		- Password from user; salted -> Hash in file
		- Verify hash matches when editing
	- Also includes sounds
		- Extract from other "TODO" .txt file

- Misc:
	- MSPaint cursors: C:\windows\systemresources\mspaint.exe.mun
	- When primary layer is other than Texture, render texture layer in texturization mode (as opposed to simple texture-sample mode, i.e. nearest neighbor)
		- This is assuming that ShipTexturizer mocks closely enough tessellation
	- Localization:
		- See if can do separate extraction into separate file, which then is loaded at all times by LocalizationManager together with the other one 
	- Ruler: pick a scale (pixels to meter of original ship), then you choose how long the ruler
		- L shaped: horizontal and vertical
		- Ruler sticks to the canvas
		- Only one ruler at a time
	- Texture Generator for ship canvas:
		- Makes larger image, with bilinear interpolation with alpha blending
			- Ain't that what we've got already for the auto-texturizer?
	- Selectable backgrounds		
	- See if it takes so long to initialize SB::MainFrame that we need IProgress
	- Preferences:
		- New ship size
		- ...all tools' settings...
		- TODO: spec
	- Inherits FullScreen state and shares state changes (so, for example, if exits full screen in ShipBuilder, also Game has exited full screen)
		- How to share state changes? 
			- FullScreenManager class, shared_ptr in both
			- Looked at at each Game<->ShipBuilder switch by receiver
	- Save ship default filesystem location: new SystemPAths (under Documents)
		- ShipLoadDialog: second "Home" location for switching to it
	- TO-SPEC:
		- What to do with background music when switching back and forth?

