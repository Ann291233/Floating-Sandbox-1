https://gamejolt.com/x/permalink/comment/11730705

= Visualization modes: (*)
	+ Each layer has a visualization mode
	+ Selectors are in new set of panels - with visibility dependent on primary layer - in LayersVisualization panel
		+ On top of grid view button
	= Modes: (each an enum in ShipBuilderTypes)
		- Structural layer:
			- Particle
			- Auto-Texturization
			- Texture (only if texture layer exists)
		+ Electrical:
			+ Particle
			- Circuit (long-term)
		+ Ropes:
			+ Lines
		+ Texture:
			+ Matte
	+ Dynamics:
		! Spec:
			- ModelController APIs take opt<viz mode> so that Controller can orchestrate turning whole layer viz on or off
				- e.g.: texture viz is only on if structure mode is particle
				- Controller is responsible for turning on/off entire layer viz - ModelController does nothing at New and Remove
		+ Controller::SetXXXVisualizationMode
			+ Set mXXXVisualizationMode
			+ Call UpdateVisualizationMode()
			+ Refresh view
			+ IUserInterface->OnXXXVizModeChanged()
		+ Hook buttons to Controller::SetXXXVisualizationMode
		+ private InternalUpdateVizModes:
			+ Called at each change of:
				+ Layer presence
					+ Including cctor
					+ Including undo restore's
				+ Viz mode change
			+ Orchestrate calls to ModelController::SetXXXVisualizationMode
		+ ModelController::SetXXXVisualizationMode(opt)
			+ if (new == old) => nop
			+ If !new && old:
				+ Free texture
				+ Clear DirtyXXXVizRegion
			+ Else if new != old:
				+ (Re)alloc texture // This moves here from UploadVisualization() and initializations (cctor and New() calls)
				+ UpdateXXXVisualization(whole region) => will update dirty region
			+ Store mXXXVisualizationMode
			+ Remove init/shutdown @ 
				+ UpdateXXXVisualization()
				+ RemoveLayer
			+ UpdateXXXLayerViz:
				+ No check for layer presence, but assert
		+ ModelController::cctor:
			+ No viz initialization, will be done by Controller
		+ ModelController::SetXXXLayer:
			+ ...set XXX layer...
			+ Note: only works like this if new size == old size, hence no realloc; see if it's also the assumption here
			+ UpdateXXXVisualization(whole region)
		+ ModelController::RemoveXXXLayer:
			+ No viz removal, will be done by Controller
		+ ModelController::UpdateVisualization
		+ ModelController::UploadViz
			+ Remove from view if has it and don't need to do
	+ Misc:
		+ MainFrame: enable/disable structural texture mode at OnLayerPresenceChanged
		+ Check out that ElectricalTexture vertex creation TODOHERE in View.cpp
		+ new texture mode for...no texture
			+ UI
				+ Icon for structure-matte
			+ Controller
			+ ModelController
			+ See UI: when texture layer is created, which one is selected
	- Auto-texturization visualization
		- ModelController::SetStructuralLayerVizMode: realloc texture for right sizes when changing between types that require different...sizes
	- Texture visualization
		- ModelController::SetStructuralLayerVizMode: realloc texture for right sizes when changing between types that require different...sizes

- Texture flood tool
	- First off: mouse coordinates from MainFrame to Controller becomes LogicalDisplayCoords, and they're converted to ShipSpace coords where needed
	- Conversion to texture coords: done by View & ViewModel, exactly like conversion to ShipSpaceCoords, and invoked by texture tool(s)
		- ViewModel also stores texture layer size (as ImageSize), next to ShipSize; set into View 
		  by Controller (via View.SetTextureLayerSize) at each texture layer size change (OR: implicitly from UploadTexture? Would be best as we don't have to remember, but what when there's no texture uploaded yet?)
			- Controller::CreateForShip
			- Controller::SetTextureLayer
			- Controller::RestoreTextureLayerForUndo
			- Controller::ResizeShip
			- No need to do at removal...

- Resize workflow:
	+ Button - in Ship Settings panel, slightly separated from the File buttons
	- Click -> Dialog for Canvas Centering/Clipping (i.e. "Anchor choice") -> Controller -> ...TODO...

- Import/Export:
	- Structural:
		- Import from:
			- .png, .shp, .shp2 (load whole and throw away)
		- Export to .png
			- ShipDeSerializer:
				- SaveStructuralLayerImage(StructuralLayerBuffer const &, ...)
	- Electrical:
		- Import:
			- .shp, .shp2 (load whole and throw away)
				- Might as well allow user to select .png's (for simplicity in ShipLoadDialog), will be discared afterwards anyway
			- Show error if no layer exists in definition
		+ No export (can save .shp2 and import from there)
	- Ropes:
		- Import:
			- .shp, .shp2 (load whole and throw away)
				- Might as well allow user to select .png's (for simplicity in ShipLoadDialog), will be discared afterwards anyway
			- Show error if no layer exists in definition
		+ No export (can save .shp2 and import from there)
	= Texture:
		= Import: two separate import buttons
			= .png
				+ New ImageLoadDialog
				= Add jpg support to DevIL
					+ http://www.ijg.org/
					= Windows
						= Devil 64 (R+D)
						- Devil 32 (R+D)
						- Test four configurations
					- Ubuntu
				- Load file and pass to Controller
					= Resize workflow
						= For texture
							+ Dialog
							= Resize image
								= Buffer2D
								- See broken Y
							= Controller::SetTextureLayer
								= Undo
							- Texture visualization (see immediately above) for testing
						= For resize
							+ Dialog
								+ Dimensions lock button
								+ When changing target size, need to honor anchor
									+ Hence need to store anchor coords, rather than just offset, and calc offset at each OnChange
									+ And if we store anchor coords, what do we do with mouse move?
										+ Reset anchor coords
										+ Should also communicate to dialog to reset anchor controls
									+ Impl:
										+ OnCustomOffset: invoke when mouse move
											+ Dialog reactor: toggle all buttons off (via OnAnchor)
										+ AnchorCoords:
											+ Calc coords at OnChange iff mAnchorCoords.HasValue()
								+ Fix the problem with super zoom
								+ Capture mouse
							- Controller::ResizeShip
								- See if it makes sense to have a helper that takes action as (template) arg and does usual prefix and postfix
								- ModelController::ResizeShip
									- Resize model
								- Undo
				- Texture-import-from-button issue: see if specifying two bitmaps works
			- .shp, .shp2 (load whole and throw away)
				- Might as well allow user to select .png's (for simplicity in ShipLoadDialog), will be discared afterwards anyway
				- Show error if no layer exists in definition
			= After import, also replace art credits
				= Empty if from image, from imported ship otherwise (even if empty)
		- Export to .png (though quite useless at this moment)
			- Ad-hoc code using ImageFileTools
	- Notes:
		- Any import from .shp2 requires password
		- All imports push an undo


- New/Set/Remove layers:
	- New:
		- Make internal helper templated on LayerType, with all code
		- Additions:
			- Undo
				- Note: texture layer clear should also remember metadata (art credits)
	- Set:
		- Make internal helper templated on LayerType, with all code
		- Additions:
			- Undo
				- Note: texture layer change should also remember metadata (art credits)
	- Remove:
		- Make internal helper templated on LayerType, with all code
		- Additions:
			= Undo
				= Note: texture layer removal should also remember metadata (art credits)

- ShipPropertiesEditDialog: ship prefix normalizer
	+ Make text file out of https://en.wikipedia.org/wiki/Ship_prefix, with just list of prefixes
	- Usage:
		- Choose: at OK button, or at focus leaving from edit box
	- Algo:
		- Take user-provided, reduce to contiguous (remove ./\<space>)
			- TODO: when to stop
		- Take list, reduce to contiguous (remove ./\<space>)
		- If the two match, use original from list
			
- App icons (whole "Resources" folder)

================================================================================================================================================================================

- Gist:
	- Code organization:
		- ShipBuilderLib project, slave of FloatingSandbox project
		- ShipBuilder project, top-level project for standalone SB UI
			- For testing ShipBuilder alone
			- Just MainApp basically
		- All in separate ShipBuilder namespace
	- Own frame for UI
	- Model, View, Controller architecture
	- Reuses existing ResourceHelper, only need (at this moment) for separate resource directory and method is Shaders ("Game" and "ShipBuilder")
	- On the "structure: pixels vs triangles", Wreno says fine to edit in pixel mode, and allow user to eventually _view_ also in triangle mode (but not necessarily edit)
	- On the size: Wreno says "no fixed sized, allow whole world"

- Architecture:

	- MainFrame: IUserInterface
	  |------------------------------>View
	  |-------> Controller/Tools		    
		    |---->ModelController
			  |---->Model
			  |------------------------>View

	- MainFrame: owns toolboxes, etc.
		- Owns Controller and View
		- Very thin, calls into Controller for each high-level interaction (e.g. SelectTool(.), OnWorkbenchStateChanged(.))
		- Implements IUserInterface with interface required by controller, e.g. UI state changes, mouse capture, undo stack visualization
		- Owns WorkbenchState
			- Candidate for saved settings
			- Contains foreground and background materials, and settings for all tools
		- Implements ship load/save logic, giving/getting whole ShipDefinition to/from ModelController
	- Controller
		- Owns ModelController, takes reference to View
		- Main Frame calls into Controller for each user interaction, including button clicks
			- Controller->Main Frame callbacks via IUserInterface
		- Maintains UI state (e.g. grid toggle, visible layers), instructing View
		- Maintains Undo stack (not individual entries), and orchestrates undo stack visualization with IUserInterface
		- Maintains interaction state, implemented via Tools
		- Owns SelectionManager pseudo-tool
		- Owns ClipboardManager pseudo-tool
	- ModelController
		- Owns Model, takes reference to View
		- Implements all interactions and algorithms (e.g. pencil, line, flood, paste, etc.), uploading resulting changes from Model into View,
		  and creating Undo stack entries		
	- Model
		- All data, (almost) no operations (anemic), fully exported
		- Modified by ModelController
		- Knows nothing about view
		- IsDirty tracking
	- View
		- Rendering of ship, all layers
		- Rendering of tool interactions (e.g. marching ants, squares, etc.)
		- Fully OpenGL
	- Tools
		- "Extensions" of Controller
		- Implement state machines for interactions, including visual notifications (marching ants, paste mask, etc.)
		- Take references to WorkbenchState (at tool initialization time)
		- Selection tool Take references to SelectionManager (at tool initialization time), so that it can save selection to it
		- Receive input state events from Controller, and notifications of WorkbenchState changed
		- Take references to View and ModelController
		- Modify Model via ModelController
		- Instruct View for tool interactions, e.g. tool visualizations (lines, paste mask, etc.)
		- Have also reference to IUserInterface, e.g. to capture/release mouse

----------------------------------------------------------------------------------------------------------

- Workflows:
	- Create New Ship (@menu, @file panel)
		- GameController::CreateNew()
	- Create New Ship From TExture (@menu, @file panel)
		- GameController::CreateNewFromTexture()
	- Load Ship (@menu, @file panel)
		- GameController::Load()

- Dirtyness:
	- Storage is at Model
		- Include metadata
	- Manipulated by Controller via ModelController methods
		- So Controller notifies IUserInterface

- UI Controls:
	+ Button to save and go back to game (!StandaloneMode)
	+ Button to quit and go back to game (!StandaloneMode)
	- Button to Save (acts also as SaveAs for first save; menu however has also separate SaveAs)
	- Undo stack
	- Error (message) notification(s)
		- StatusBar w/tooltip?
	+ Add electrical/texture/ropes layer
	- Button to open ShipMetadata dialog
	- Resize button (canvas resize)


- StatusBar:
	+ Own class
	- Try making it a wxPanel rather than a wxStatusBar
	- Cctor and Set(.) for UnitsSystem
		- From SB::MainFrame cctor
		- And store tools coords, ship size, etc. for re-populating on change	
	- Areas:
		- Canvas:
			- Coords and icon (x,y), w/meters/feet as well
			- WorkSpace size and icon (wxh), w/meters/feet as well
			- Selection/line/rect/etc. size and icon (wxh), w/meters/feet as well
			- Zoom (%)
				+ MainFrame: OnViewModelChanged calls a new ReconciliateUIWithViewModel(), which does:
					+ StatusBar: set zoom
					+ RecalculateWorkCanvasPanning
			- Material under cursor (for drop tool)
			- Warning icon (w/tooltip)

- Tools:
	! Most tools should pan when the (captured) mouse is outside of the canvas
		- Via BaseTool::ScrollIntoViewIfNeeded, which simply forwards to IUserInterface::ScrollIntoViewIfNeeded(display logical)
	+ Tool:
		+ Stores all protected references passed from cctors: IUserInterface, ModelController, View
		+ Same abstract methods from game - but all pure
	- All tools:
		+ Pencil (S, E)
			+ Settings: Size
		+ Eraser (S, E)
			+ Settings: Size
		+ Flood (S, E)
		- Sample
		+ Line
		- Rectangle
			- Settings: FillWithFore|FillWithBack|NoFill; Size
		- Selection
			- Implements selection interaction and rendering of visual feedback *during the interaction only*
			- Takes SelectionManager ref in its cctor, and populates it upon confirmation of selection made
		- Ellipses
		- Traslate (aka move)
		- Magic Eraser (for texture layer only)
			- Tolerance (0-100): % of distance(this color, start color)/max_distance
			- Anti-aliasing (bool): when on, alpha = distance(this color, start color)/tolerance_distance
	- SelectionManager pseudo-tool:
		- Maintains current selection
		- Not really a tool but a pseudo-tool
		- Takes View so that it can instruct it to render marching ants
			- Is not responsible for drawing of temporary selection while the user is making it, that is the Selection tool
		- Read by ClipboardManager pseudo-tool to make clip
		- TODO: templated on layer type?
	- ClipboardManager pseudo-tool:
		- Maintains clip
		- Implements operations: Copy, Cut, Paste
			- TODO: who should be responsible for the interactions during Paste? See Photoshop and Paint
				- A different, unselectable tool?
		- Talks with IUserInterface to enable/disable menus
	- Other edit operations, not via tools - via menu (and buttons?)
		- Auto-trim (on bounding box)

- RenderContext:
	- Single-threaded
	- Initializes on same canvas that main frame initializes on
		- So needs to be passed to SB::MainFrame's cctor
		- TODO: after or before? Better before for less chance of side effects?
			- Ideally other context is removed before new one is set
			- See if can move global GameOpenGL initialization outside of Game RenderContext and into ::MainFrame initialization, before both
	- Renders synchronously, on-demand via SB::MainFrame::OnPaint()
		- Except when we need animated tools, e.g. ants walking: for these we set a timer (in the order of 100's of ms) during the duration
		  of the tool
			- via an IUserInterface method, and another call to stop it ("SetAutoRender(bool)")
	+ ViewModel:
		+ Terminology:
			+ WorkSpace: has the pixel size of the structure (equivalent of ::World)
			+ WorkSpaceCoordinates (type @ ShipBuilderTypes)
			+ DisplayLogical: has the logical display (window) size (equivalent of ::Logical)
			+ DisplayLogicalCoordinates: the logical display coordinates (type @ ShipBuilderTypes)
			+ DisplayPixel: has the pixel display (window) size (equivalent of ::Pixel)
			+ DisplayPixelCoordinates: the pixel display coordinates (type @ ShipBuilderTypes)
		+ World coords is model pixel coords, i.e. WorkSpace
		+ Tells outside world of pan extent (for scrollbar width setting)
	- Primitives:
		+ Background text
		+ Structural RenderColor Texture
		- Electrical RenderColor Texture
		- Pseudo-cursor
			- One of many types; removed with a single call


- WorkbenchState
	+ Independent from model - exclusively tools-related settings
		+ So no need to reset/change/update at new model creation
	= cctor: (MaterialsDB, SB::PreferencesManager)
		+ FW and BG materials: always "defaults" from MaterialsDB
		- other settings: loaded from SB::PreferencesManager

- Validations:
	- Move validations to own class - ModelValidator
	- Electrical connectivity validation
		- Start visit from all sources
		- Assume all switches, etc. are conductive
		- Make sure all sinks have been reached

= Ship file format:
	+ Fixed endianness
		+ See https://github.com/voidah/archive/blob/master/archive.h
	+ FS version
		+ Only used for warnings in case materials not found and cur version > file version
	+ "File lock" which disallows editing
		! Password from user; salted -> Hash in Metadata
		! Verify hash matches when editing
	- Also includes sounds
		- Extract from other "TODO" .txt file


- Ubuntu:
	- Test User Ships folder

- Misc:
	- When primary layer is other than Texture, render texture layer in texturization mode (as opposed to simple texture-sample mode, i.e. nearest neighbor)
		- This is assuming that ShipTexturizer mocks closely enough tessellation
	- Localization:
		- See if can do separate extraction into separate file, which then is loaded at all times by LocalizationManager together with the other one 
	- Ruler: pick a scale (pixels to meter of original ship), then you choose how long the ruler
		- L shaped: horizontal and vertical
		- Ruler sticks to the canvas
		- Only one ruler at a time
	- Texture Generator for ship canvas:
		- Makes larger image, with bilinear interpolation with alpha blending
			- Ain't that what we've got already for the auto-texturizer?
	- Selectable backgrounds		
	- See if it takes so long to initialize SB::MainFrame that we need IProgress
	- Preferences:
		- New ship size
		- ...all tools' settings...
		- TODO: spec
	- Inherits FullScreen state and shares state changes (so, for example, if exits full screen in ShipBuilder, also Game has exited full screen)
		- How to share state changes? 
			- FullScreenManager class, shared_ptr in both
			- Looked at at each Game<->ShipBuilder switch by receiver
	- Windows installer (or ShipBuilder::MainFrame cctor): on Windows, register shell icon handler for .shp2 files, and icon
		- Or done at app startup, #ifdef Windows
	- Each time we StartTool() (e.g. at AddLayer, etc.) we end up refreshing modelcontroller's visualization and OpenGL visualization, twice
	- TO-SPEC:
		- What to do with background music when switching back and forth?

- Ephemeral visualization rearch:
	- Current structure:
		- Tool::ctor, Tool::EndEngagement: Take orig clone
		- @ Do:
			
			- DoFillForTempVisualization
				- Layer + Render buffer, ONLY
			- DoFillForTempVisualization
			- DoFillForTempVisualization ...

			- UploadVisualization
			- RefreshView
		- @ Mend, @ End:
			- RestoreStructuralLayerRegionForEphemeralVisualization(orig clone)			

			- UploadVisualization
			- RefreshView
		! Total cost:
			- Tool create: 1 alloc + 1 full copy
			- Tool move: 1 region blit + 1 region fill + 1 full upload
			- Tool end: 1 region blit + 1 full upload
	- Proposed structure 1: token (aka "session")
		- Spec:
			- High-level:
				- The "real" model is never changed during temp visualization
				- The token/session wraps ModelController, providing the latter with own buffers when doing ops on temp viz
					- ModelController operations that happen on both model and temp viz model are implemented generically so they accept external buffers as well
						- Outsourced data:
							- Layer itself
							- Layer viz + its Dirty region == struct LayerVisualization { uq_ptr<RgbaImageData>, opt<Rect> }
			- Tool::ctor, Tool::EndEngagement: 
				- ModelController::InitiateTempVisualization() -> TempVisualizationToken
					- TempVisualizationToken::cctor: take orig clone
					- Tool stores token
			- @ Do:
				- TempVisualizationToken::DoFillForTempVisualization
					- Forwarded to ModelController
				- TempVisualizationToken::DoFillForTempVisualization
				- TempVisualizationToken::DoFillForTempVisualization ...

				- TempVisualiationToken::Render
					- UploadVisualization
					- RefreshView
			- @ Mend:
				- TempVisualizationToken::UndoTempVisualization
					- RestoreStructuralLayerRegionForEphemeralVisualization(orig clone)			

					- UploadVisualization
					- RefreshView
			- @ End (dctor):
				- Same as @Mend
			! Total cost:
				- Tool create: 1 alloc + 1 full copy
				- Tool move: 1 region blit + 1 region fill + 1 full upload
				- Tool end: 1 full upload
		- Details:
			- ModelLayerEphemeralVisualizationSession<TLayer>
				+ Not copyable, yes moveable
				- Members:
					- References to arch members:
						- ModelController &
					- TLayer mOriginalLayerClone
					- LayerVisualization mWorkVisualization
					- Session:
						- DirtyRegion == std::opt<Rect>
				- cctor(ModelController &):
					+ Take original layer clone
					+ Initialize session
						+ DirtyRegion=nullopt
				- Fill(rect, material)
					- 
				- Mend()
					-
				- ~dctor():
					- 
		- TODOs:
			+ Clone rearch

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
DONE
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------

+ Move/merge integral coords/size from shipbuilder to game
	+ Game: "ShipSpace" and "DisplayPhysical/Logical"		
	+ ShipBuilder

+ SB::ViewModel: ortho matrix: see again why ShipSpace says positive bottom
	+ Anchor to the top

+ LayerBuffer.h: "layer buffer" types
	+ StructuralLayerBuffer == Buffer2D<StructuralElement, ShipSpace>
		+ StructuralElement = <StructuralMaterial*>
	+ ElectricalLayerBuffer == Buffer2D<ElectricalElement, ShipSpace>
		+ ElectricalMaterial = <ElectricalMaterial*, instance ID>
	+ RopesLayerBuffer == Buffer2D<RopeElement, ShipSpace>
		+ RopeElement = <StructuralMaterial*, endpoint ID>
	+ TextureLayerBuffer == Buffer2D<rgbaColor, ImageSpace>

+ Use "layer buffers" at ShipFactory
	+ ShipMaterialization class (@GameLib): four buffers
	+ static ShipFactory::MaterializeShip(...) -> ShipMaterialization
		+ See first if can make whole ShipFactory static again
		+ Also includes filling-in Ropes from rope endpoints found in structure (legacy)
			+ Throw on conflicts, like (should be) now
		+ Also includes filling-in Electrical from electrical materials found in structure (legacy)
			+ Throw on conflicts, like (should be) now
	+ ShipFactory::WhateverNow(): use MaterializeShip to get ShipMaterialization and continue from there
		+ Given that you're at it: ShipFactoryTypes::ShipFactoryPoint: nuke vec2i and replace with ShipSpaceCoordinates (and user-facing coords being ImageCoordinates)
	+ Test:
		+ Basic:
			+ Legacy ropes
			+ Native ropes
			X Legacy+Native ropes
			+ Legacy electrical
			+ Native electrical
			X Legacy+Native electrical
			+ Texture
		+ Corner cases:
			+ Ropes: too many endpoints for same Rope ID
				+ All legacy
				+ All native
		+ Both auto-texturization settings
		+ Perf (before & after)
			+ Before: ~100ms (factory including auto-text)
			+ After: ~110ms

+ Check if also old code asserted on Szerszen cargo for hull

+ Ship De/Serialization
	! Spec:
		- Ultimate ship definition consists of LayerBuffers, not images (except for Texture obviously)
		- ShipMaterialization functionality currently in ShipFactory should move to legacy ship deserializer, for formats "png" and "shp"
			- This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
	+ Impl:
		+ ShipMaterialization also carries all attributes of ShipDefinition
		+ ShipDeserializer			
			+ Load(filepath, MaterialDB) -> ShipMaterialization
				+ ShipMaterialization functionality currently in ShipFactory should move to legacy ship deserializer, for formats "png" and "shp"
					+ This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
				+ png
				+ shp
			+ LoadPreview(filepath, MaterialDB) -> ShipPreview
				+ png
				+ shp
			+ Save(ShipMaterialization, filepath)
				+ NOP at the moment
		+ Nuke ShipPreview.cpp
		+ Nuke ShipDefinition.*, ShipDefinitionFile.*
		+ "ShipMaterialization" -> "ShipDefinition"
		+ Use ShipDeSerializer ipv ShipDefinition::Load
			+ ShipDefinition
			+ ShipPreview
		+ ShipFactory:
			+ Nuke MaterializeShip code, just begin with ShipMaterialization (now ShipDefinition) as arg

+ Review whole need of ropes creating structural endpoints @ load type from .shp files
	+ Do at ShipFactory::Create() within the first pass on Ropes (i.e. ExtractRopeSegments => PostProcessRopesLayer())
		+ Fix Szerszen
		+ Fix hull assert
		+ Fix RopesTest for Frontiers crash
	+ And subsequently, check the need for StructuralElement to have RenderColor

+ Model contains the four new layer buffer types (1 as member, 3 as uq_ptr)

+ Merge into shipbuilder

+ Undo
	+ Hierarchy: there are four subtypes of UndoEditAction - for each of the "layer buffer" types - on top of e.g. "resize" and "all layers"
		+ These four are all implemented via a single templated class, templated on TLayerBuffer
			+ Contains TLayerBuffer and origin
		+ Apply() invokes Controller::RestoreLayer(TLayerBuffer const &, origin)
	+ Dirtyness:
		+ Model::DirtyState == {array, metadata, ...}, w/=operator
		+ Base UndoAction has DirtyState member, given via cctor & exposed via getter
		+ Controller::Undo()

+ Auto-zoom on new ModelController
	+ By Controller, at cctor (i.e. after CreateNew() and CreateForShip())
		+ Via ViewModel->CalculateIdealZoom() const -> zoom, then set in ViewModel		

+ Grid view:
	+ Button right of transparency slider
	+ Controller->View
	+ View takes it in cctor
	+ Shader

+ Toolbar rearc:
	+ File panel
	+ Ship settings panel
		+ Resize
		+ Ship metadata
	+ Tool settings panel
	+ Check in-game

+ Replace "Yes/No are you sure" with "Do you want to save your changes before continuing?" -> Yes, No, Cancel
	+ "AskUserIfSure" -> "AskUserIfSave" => returns int (wxID_YES, wxID_NO, wxID_CANCEL)
	+ On yes, call SaveShip(), and if the latter returns false, take the Cancel route

+ ShipLoadDialog: doesn't catch new file
	! It's because at open we don't scan directory unless we've changed directory
	+ Solution:
		+ At open, if haven't changed dir, build map (ordered) of <filepath, last_modif> 
		+ Then compare map with same map built at PreviewReady handling
			+ Requires message to also contain last_modif
		+ If changed: follow same path as if directory changed
		+ Also: make snapshot as above, and then also passes it to thread as replacement of thread's first step
			+ Move ShipPreviewDirectoryManager::EnumerateShipFilePaths to here basically, improving it as we may avoid storing files if not ship files

+ New/Load/Save Ship
	+ Move ShipLoadDialog/etc. under UILib
		+ Test from game:
			+ Last directory is added to both ComboBox and UIPreferences
				+ Yes when loaded
				+ No when not loaded
			+ Show ship descriptions:
				+ Works in dialog
				+ Works at load
				+ User may override
		+ Second home button
	+ New
		+ UI: menu + button
		+ Always enabled
		+ Asks user if model dirty
		+ Invoke DoNewShip()
	+ Load
		+ UI: menu + button
		+ Always enabled
		+ Asks user if model dirty
		+ Open file load dialog
		+ If OK: invoke DoLoadShip(selected filename)
		+ TEST: in Game, 2 dialogs
	+ Save:
		+ UI: menu + button 
		+ Only enabled when dirty
		+ if !mCurrentFilename: invokes SaveAs(); else: invokes private SaveShip(mCurrentFilename)
	+ SaveAs:
		+ UI: menu + button
		+ Only enabled when dirty
		+ Open file save dialog for .shp2
		+ If OK:
			+ Invoke private SaveShip(selected filename)
		
	+ DoNewShip:
		+ Do
	+ DoLoadShip:
		+ Do
		+ Store filename as mCurrentFilename
	+ DoSaveShip:
		+ Ship Preview workflow:
			+ ShipDeSerializer: split out legacy into own class
			+ ShipDeSerializer: LoadShipPreviewData() and LoadShipPreviewImage(ShipPreviewData const &)
			+ ShipPreview ("ShipPreviewData") from .shp2 contains .shp2 filepath itself
			+ ShipDeSerializer::LoadShipPreviewImage: if type is shp2, call ShipDefinitionFormatDeSerializer::LoadPreviewImage(filepath)
				+ else: type can only be png (throw if not) - call legacy LoadPreviewImage() which loads image
				+ Then resize and trim (like it was @ ShipPreview)
			+ .shp2 format: preview is own tag, image chunk saved at ship save time - but only if there's no texture
				+ Order of chunks:
					+ If has texture: metadata, texture, ...
					+ Else: metadata, preview, ...
				+ Do LoadPreview
					+ Have one single main loop for the three load calls
		+ ShipDeSerializer::Save(ShipDefinition const &)
			+ Rearc exceptions:
				+ GameCore/UserGameException
					+ With enum
					+ Exception contains enum and string array
					+ LocalizationManager::MakeErrorMessage(LocalizableGameException const &)
						+ Formats
					+ Catch-&-localize @ callers
						+ Game
						+ ShipBuilder
						+ Preview
				+ Individual methods throw directly LocalizableGameException, no post-processing
					+ DeSerializationContext: private class with file FS version, stored as pair of integers
						+ Nuke MajorMinorVersion class
				+ Unit tests for all exceptions
					+ Header
					+ Unrecognized material in structural layer
				+ Test all w/localized strings
					+ Game
					+ ShipBuilder
			+ Header
			+ Metadata
			+ Ship size section
				+ And no size at buffers
			+ Replace ShipSize with struct ("ShipAttributes" or "ShipFoundamentals") having ship size, hasTexture, hasElectricals, FS version
				+ As a section, made of sub-sections
				+ Section is checked for presence before use, and sub-sections are checked for presence before constructing ShipFoundamentals
				+ Unit tests
			+ Preview
				+ Trim in-place
				+ Make sure image trimming happens only for legacy
			+ Structural layer
				+ RLE with variable-length "u 16-bit" count encoding
					+ DeSerializationBuffer::Read/Write VarUInt16
					+ Orig: 216Kb
					+ Compressed: 30.8Kb
				+ Read
					+ Then complete unit tests
		+ Store filename as mCurrentFilename
		+ Also do load for .shp2
			+ ShipLoadDialog wildcards
			+ ShipDeSerializer::Load():
				+ Header: check (via helper)
				+ Metadata
				+ ...
				+ Verify tail

+ Add some shading around ShipSpace canvas
	+ Four 1-pixel-wide quads drawn with matte color (black)
	+ If we use the same ortho matrix, we need to calc the ship space size of 1 pixel

+ Click-And-Draw use case:
	+ Structural Pencil tool (*)
		+ UndoStack.h/cpp, w/IUndoEntry interface w/UndoEntryType enum
		+ Controller: forward mouse events to tool
		+ View:
			+ Upload method for texture *region*
		+ Application: undo is only baked and added at mouse up, containing whole affected region
			! Spec:
				+ Tool makes clone of entire region at mouse down
				+ At each pixel edit, tool updates region's origin and size
				+ At mouse up, tool makes UndoEntry with clone of material region 
			+ Impl:
				+ Pencil tool is templated on LayerType
				+ Tool has std::opt<InteractionState> with ShipSpaceRect and clone of entire region
					+ LayerTypeTraits<LayerType> gives type of LayerBuffer					
				+ At mouse down: 
					+ Model::CloneStructuralLayerBuffer() -> StructuralLayerBuffer
					X Then capture mouse
				+ At mouse up, tool makes UndoEntry with clipped clone of material region 
					+ Buffer2D has method to be "regionized" (restricted)
						+ Unit tests
					X Then release mouse
					X Then set Model::StructuralLayer as dirty
			+ ModelController::XXXRegionFill does not return UndoEntry anymore
		+ See if OnMouseOut at Tool is really needed
		+ Undo stack:
			+ Owned by Controller, given to Tool
			+ Tool's action writes into UndoStack and invokes IUserInterface notification
			+ IUserInterface notification: Undo menu item
			+ MainFrame: on Undo, call into Controller::Undo()
			+ Controller::Undo:
				+ Calls UndoAction::Apply(this)
				+ Restores dirty state
		+ UndoEntry exposes:
			+ string GetTitle()
			+ std::uint64_t GetCost()
			+ void Apply(Controller &)
				+ Double-dispatch
		+ Controller::RestoreLayerBufferRegion(...) X 4:
			+ Invoke ModelController::StructuralRegionReplace(...)
				+ assert model has layer
				+ Do
				+ Recalc derived
			+ Mark layer as dirty
			+ Notify IUserInterface of dirtyness
		+ Fill-in mouse pointer jumps
			+ Function that takes two integral endpoints and calculates line path, at GameGeometry.h
				+ UnitTests
			+ Use it at PencilTool::CheckEdit:
				+ EnagementData has optional<ShipSpaceCoords> previousEngagement
				+ When we leave CheckEdit because out of bounds, we reset previousEngagement
				+ At application:
					+ Do RegionFill along the path
				+ After we apply the edit, we set previousEngagement
		+ Tool settings: size
			+ Size panel
			+ PencilTool: use size
			+ Rearc layer visualization
				+ Move buffers from Model into ModelController
					+ Add to model controller
					+ Remove from Model
				+ ModelController:
					+ Introduce dirty system for visualization layers: Update() sets dirty region, Upload checks which, uploads, and clears
						+ Single Upload, remove four individual ones
					+ Remove visualization layers upon removal of layers
				+ Controller & Pencil: in a single helper method: 
					+ Ask ModelController to upload visualization (which is based on dirtyness of visualization buffers)
					+ Ask UIInterface to Refresh()
				+ View: terminology: "StructuralLayerVisualizationTexture"
				+ Rethink removal of layers: need to trigger "turning off" of View textures
					! Sequence is: update (@MC), upload (@C)
					+ View::HasStructural/.../Texture() -> bool
					+ MC::Upload: if MC !have && view.has => View::RemoveStructural/.../Texture()
			+ Preview: 
				+ <from Moleskine>
				+ OnCaptureLost: reset tool
					+ Instead of current implementation
				+ Tool cctor: checks IUserInterface::IsMouseInWorkCanvas, based on actual hit test				
				+ OnMouseEnter: Nothing (remove)
				+ OnMouseLeave: forwarded only if not captured (by WorkCanvas)
					+ Tool: Mend temp visualization
				+ FIX: click on scrollbar causes "view change" hence a MouseMove on tool
					+ Controller::SetCamera: only do mouse move if mouse *in* work canvas, and *not* captured by any scrollbar
			+ Anchor
	+ Structural Eraser tool:
		+ Reuse pencil tool, with extra template arg

+ Default ship name (remove TODO)
	+ Use date & time
	+ Helper to make filename (in Utils)
	+ Use it when opening SaveAs

+ Eraser cursor

+ Electrical layer:
	+ Load and Save at DeSerializer
		+ Review MaterialDatabase's electrical material maps: make one map?
			+ Test:
				+ Load png ship with legacy electrical materials
				+ Load .shp ship with instanced and non-instanced materials
	+ Full electrical layer support, like structural
		+ Model
		+ ModelController
		+ Controller
		+ Undo
		+ PencilTool
		+ MainFrame
			+ Hook load->Model
			+ Hook Model->save
			+ LayerPanel
		+ View
			+ Electrical texture parallel
	+ PencilTool: 		
		+ Fix instance index given to fill: strategy for instance ID assignment: fully assigned by ModelController
			+ All primitives invoke internal WriteElectricalParticle(.)
				+ Carefully compare before & after to retain instance ids, create new ones, or reclaim old ones			
					! Strategy to ensure only consecutive IDs, OR only "initial" ones (even if scattered): use ElectricalElementInstanceIndexFactory, member of ModelController
					+ Keep instance IDs in-sync:
						+ ModelController cctor(def):
							+ Visit electrical layer and register existing instance indices w/factory
								+ Do in helper method, which also takes care of Factory::Reset()
									+ "InitializeElectricalLayer()", sets and does the elec analysis initialization below
							! Metadata::ElectricalPanelMetadata is already consistent
						+ New:
							+ Factory::Reset()
						+ Set (Load): 
							+ Visit electrical layer and register existing instance indices w/factory
								+ Do in helper method, which also takes care of Factory::Reset()
						+ Remove:
							+ Factory::Reset()
						+ ElectricalRegionFill						
				+ Also keeps count of electrical particles (for later analysis)
					+ Count initialized - via InitializeElectricalAnalysis() - at cctor,New,Set,Remove
						+ InitializeElectricalAnalysis():
							+ count = 0
							+ if buffer != nullptr: count
					+ Keep count updated
				! Technically, also does running analysis
				! Also takes care of electrical panel: new/removed/updated-type components								
	+ Re-do:
		! Spec:
			! Temp visualization (Fill and Mend) should not update analyses, nor EPM, nor instance IDs
			! Actual committed action (e.g. fill) should update analyses, EPM, and instance IDs
			! Undo: should replace EPM as well, and re-initialize analyses
		+ Impl:
			+ ElectricalLayer contains ElectricalPanelMetadata
				+ "LayerBuffer" -> "Layer" (source file name and type names)
				+ Take map element and map using from GameTypes
				+ Remove EPM from ShipMetadata
				+ LegacyDeser: json is parsed in two phases
				+ De/Ser:
					+ ElectricalLayer has sub-tags (Buffer and ElectricalPanelMetadata)
						+ Unit tests
					+ String tag values?
						+ 'S', 'T', 'C', '1' => S << 24 + T << 16 + C << 8 + '1'
				+ ModelController:
					+ cctor(def): make sure EPM is stored
					+ New: make sure EPM is zerod
					+ Set: make sure new EPM is stored
					+ Remove: make sure EPM is nuked
			+ UndoEntry of electrical must also contain whole ElectricalPanelMetadata
				+ It's Layer + Origin
				+ Should also fly with Structural
			+ Fill and Mend/Replace are split in two:
				+ FillElectricalLayerRegionForTempVisualization and RestoreElectricalLayerRegionForTempVisualization: 
					+ Just populate layer buffer; do not update analyses, nor EPM, nor instance IDs
					+ NOTE: "ForTempVisualization" -> ForEphemeralVisualization
					+ Maintain boolean for asserting at Fill and at RestoreElectricalLayerRegionForTempVisualization
				+ Fill:
					+ Populates layer buffer, and updates analyses, EPM, and instance IDs
						+ Via WriteElectricalParticle(.)
				+ RestoreElectricalLayer: for undo only
					+ Takes also EPM (simply by Layer, arg together with Origin)
					+ Blits layer region
					+ Re-initializes layer (analyses, and instance IDs - EPM already reset)
					+ Replaces EPM in own layer (by move)
					+ Args are by move
				+ Replace(.) goes
	+ Refactor StructuralRegionReplace in the same way (w/WriteStructuralParticle, mending/replace, etc.)
		+ StructuralFill also takes material* instead of element
		+ InitializeLayer & its calls
	+ Tests:
		+ Can load electrical in game, and has panel
		+ PencilTool
			+ Instance ID assignment
		+ PencilTool + Undo
			+ Instance ID assignment
		+ Make sure loading a ship w/legacy electricals makes up an electrical layer, and saving it saves the electricals
	+ Try: do not make line if instanced electrical element
	+ View: other layers' opacity  (NO visualization type! (yet))
		+ View::Set...: stores member
		+ Set param in shader at each use of the shader (i.e. at each layer rendering)
			+ Based on mPrimaryLayer
				+ Do setter and call setter from Controller, prior to visualization update
		+ Controller must refresh (just) rendering (not whole ModelController visualization!)
		+ Primary layer dynamics:
			+ Storage @ Controller				
			+ Controller::cctor sets it in view
			+ Controller::ChangePrimaryLayer: also set in view
		+ OtherLayersOpacity dynamics:
			+ Storage at view
				+ View has it among uploaded
			+ MainFrame: @ view creation: set value on slider, via OtherLayersOpacitySliderToOpacity
			+ MainFrame: @slider change: set value on Controller, via OtherLayersOpacityToSlider
				+ Controller::SetOtherLayersOpacity: sets also in view
			+ See TODOTEST log for opacity values
		+ StructuralLayer: no white BG? Then need BG @ View
			+ Shader: need to take pixel step parameter

+ Flood tool

----------------------

+ Validations:
	! Overview:
		! Validations may either be run by user, or run automatically before saving
		! Errors prevent ship from being saved
		! Some validations also run continuously
	+ Impl:
		+ Object model:
			+ ModelValidationResults:
				+ vector<ModelValidationIssue>
				+ Errors, Warnings, Successes
			+ ModelValidationIssue:
				+ Type
		+ Dialog:
			+ Populate results
				+ ForShipSave: all errors first, then warnings - no success					
				+ ForValidation: as they come
					+ Use sizer->Insert()
				+ Message of issue must be different when success, or title + message
					+ And no Fix button
				+ Handle issues as specific
					+ ElectricSubstratum: button for trimming
						+ Fix OpenGL-on-separate-thread issue
							+ Split Controller::Validate w/SuspendTool/ResumeTool
								+ assert from Validate that it's not in eph viz
								+ Also at MakeDefinition
							+ Suspend/Resume called from main thread in validation dialog
						+ Fix issue with temp viz drawing at ResumeTool()
							+ Should Controller suspend tool automatically at LeftWindow and resume at EnterWindow?
								+ Both only if !captured
							+ Do ToolGuard RIAA - should remember whether it really suspended or not, and resume at destructor only if it did suspend
								+ And at ValidateModel: should now be able to safely simply suspend/resume
								+ And at RestoreLayerRegion
						+ Store undo at Controller::Trim
							+ ModelController::Trim must return region
					- Visualize other issue types
				+ Message before errors and message before warnings - in ForSave mode		
		+ See if can have gauge also @ save
			+ SessionData::IsInValidationWorkflow
				+ Init: false
			+ @timer end:
				+ If IsForSave && all success && !IsInValidationWorkflow:
					+ EndModal(OK)
				+ Else:
					+ IsInValidationWorkflow = true
					+ ShowResults
			+ UI:
				+ cctor: no sizes
				+ ShowModalForStandAloneValidation:
					+ this->SetMinSize(-1, -1)
					+ this->Fit()
				+ ShowModalForShipSave:
					+ Caller doesn't calc nor passes validation
					+ this->SetMinSize(-1, -1)
					+ this->Fit()
				+ ShowResults:
					+ this->SetMinSize(...size...)
					+ this->Fit()
			+ ShowResults:
				+ Not fit
			+ Fix first StartValidation @ ShowModal's: should be called after ShowModal has caused LeaveWindow on WorkCanvas
		+ Dialog open for ship save:
		+ Do validations:
			+ ShipSizeTooBig
			+ Empty structural
			+ TooManyLights
		+ Test
			+ Workflow 1: validation
			+ Workflow 2: save
				+ When there are errors
				+ When there are no errors and there are warnings
				+ When there are no errors and no warnings

+ Mattia makes ship
	+ YouTube
	+ GameJolt post

+ At selection of new primary layer (in Controller): select first tool
	+ Or remember tool per-layer
		+ Have array for all layer types (int) storing tool type
		+ Controller::SetTool:
			+ Store this tool as last tool of primary layer
		+ Controller::SetPrimaryLayer:
			+ After switching UI: set last tool for new primary layer
	+ Fix:
		+ New code creates tool (via SetTool invoked to set last tool for layer) while tool is "suspended", @ NewLayer & RemoveLayer, when we set PrimaryLayer
		+ SetTool, SetPrimaryLayer, NewLayer, RemoveLayer: they all call InternalSetTool & InternalSetPrimaryLayer

+ Eraser square?
	+ See paint: has it
	+ View: EraserSquareOverlay

+ EraserSquareOverlay -> RectOverlay
	+ Rename
	+ Try it also with normal pencil

+ Pencil electrical: not on empty structural
	+ Eph viz: red rect overlay when on empty
		+ Shader
	+ Do action: no fill when on empty

+ No flood for electrical layer
	+ Simply remove specialization
	+ Also remove ModelController::Flood specialization

+ Flood: settings: adjacent

+ UnderConstructionDialog
	+ Do at remaining layer buttons

+ Send for testing

+ Password Workflow
	+ Hash algo at ShipDeSerializer via static helper method
	+ Workflows
		+ Save: ShipDeSerializer::CalculatePasswordHash(password): +salt => hash (new GameType) => in metadata
		+ ShipBuilder::Open and Game::EditInShipBuilder and various layers' Import: after load, if ShipMetadata has password:
			+ Ask password
				+ Workflow for wrong password
					+ Dialog w/timer, EndModel @ 3rd round
					+ "Invalid password"
					+ "Retry in {}..." (iff ! last time)
					+ Max 3 times
			+ ShipDeSerializer::CalculatePasswordHash(password) => check with metadata
			+ All in own dialog, in static bool CheckPasswordProtectedEdit(shipDefinition) which includes workflow
			+ Do at:
				+ ShipBuilder::OpenForShip
				+ Menu/Button LoadShip
	+ Test:
		+ Save ship w/password
		+ 1. Load it in FS & Open ship builder
			+ Password OK
			+ Password not OK => NewShip
			+ Frame is not yet open when password is asked
				+ Fix
				+ Test:
					+ From FS:
						+ Edit PW ship => ok pwd
						+ Edit PW ship => no pwd
						+ Edit non-PW ship
						+ Create new ship
					+ From builder:
						+ Create new ship
		+ 2. Load it in builder
			+ Password OK
			+ Password not OK => no change

+ Undo stack visualization
	+ UndoPanel underneath toolbar
	+ Controller exposes GetUndoStack() const
		+ And UndoStack exposes index-based enumerator 
	+ MainFrame can tell Controller to rewind undo to a given stack entry, by index
	+ HighlightableTextButton

+ Complete Load/Save/Model
	+ Finalize storage of all other ship definition members in Model
		+ AutoTexturizationSettings
			+ Test w/PropertiesDialog
	+ ShipDeSerializer: Load/Save each of:
		+ Electrical layer
		+ Ropes layer
		+ Texture layer
			+ Using DevIL lump, see https://github.com/DentonW/DevIL/blob/master/DevIL/src-IL/src/il_io.cpp#L2490
		+ PhysicsData
		+ AutoTexturizationSettings
			+ Test
				+ w/PropertiesDialog
				+ Load .shp -> Save .shp2 -> Load .shp2 in FS

+ Metadata edit workflow:
	+ ShipPropertiesEditDialog
	+ Dialog::Open takes Controller &, Metadata const &, PhysicsProperties const &, etc.
		+ Pass bool HasTexture (to enable ArtCredits)
		+ opt<struct> mSessionData
		+ Populates all controls
		+ Flags each control as being not dirty
	+ Editing a field flags it as being dirty
	+ Ship name
	+ Author(s)
	+ Art Credits
		! Spec: we allow ModelController to carry stale credits when texture is removed - OR NOT: replace won't signal layer removal
		+ Enabled and populated only iff HasTexture
		+ ModelController: remove ArtCredits when texture is removed
			+ Test
		+ Test
	+ Year Built
	+ Edit Password
		+ Make new tab
	+ Description
		+ Separate tab
		+ Populate at startup
		+ Check for dirty @ OK
		+ Give to ModelController at OK
	+ PhysicsData
		+ Populate tab
			+ ShipOffsetVisualizationControl
				+ Zoom calculation:
					+ Integral/ShipSpace - coords to/from world
					+ Add CoordsRatio to ShipMetadata
						+ Legacy loading: 1:1
						+ New Format loading:
							+ defaults to 1:1
							+ Load it
							+ Save it
							+ Test
					+ Use it @ ShipOffsetVisualizationControl
						+ Test it w/4:1
					+ Use it @ ShipFactory
		+ Populate UI at startup
		+ Give to ModelController at OK
			+ Verify becomes dirty
			+ Verify all 3 saved
		+ See why pressure is not 1.0 at startup
	+ Auto-Texturization Settings
		+ Populate tab
			+ Radio button to handle Remove vs Setting values
			+ Whole tab disabled <=> has texture
			+ Consider using explanations
				+ Use icons, like password
				+ Auto-texturization mode "radios"
				+ Horizontal sliders, explanation below
					+ SliderControl needs to take own HORIZONTAL vs VERTICAL enum
						+ SettingsDialog
					+ Explanation below
				+ Add some V spacing around sliders
		+ Populate UI at startup
			+ Move default AutoTexturizationSettings to default cctor of AutoTexturizationSettings
				+ Out of ShipTexturizer
		+ Give to ModelController at OK
	+ At OK:
		+ For each of Metadata, PhysicsProperties, etc:
			+ Check if any of this area's controls are dirty; if so:
				+ Construct new Metadata, PhysicsProperties, etc.
					+ Set optionals to nullopt if trimmed field is empty
				+ Call Controller::ReplaceMetadata(&&), etc.
					+ Which in turn invokes IUserInterface callback for refreshes, which do NOT reach edit dialog though
			+ Make Undo entry @ Controller
				+ Try: GenericUndo, with lambda that just takes Controller and captures things
				+ For undo entry: need one single Controller method for all pieces, with opt args (e.g. opt<opt>)
				+ Test
			+ IUserInterface callback: change it to ShipNameChanged
				+ Call it also at undo
				+ Do workflow for rename here:
					+ MainFrame: compare output of MakeFilename() on new ship name with current filename, and if different && there is a current which exists as a file:
						+ Ask rename
							+ If yes:
								+ Rename file (filesystem)
								+ Change current
							+ If no:
								+ If has a current: clear current (and Save will become SaveAs)
								! If has no current: Save is already set to become SaveAs, we're OK
	+ Tests:
		+ Load & save ship w/auto-texturization settings
		+ New ship:
			+ Populate one x {...}
			+ Close
			+ Reopen - verify it's there
			+ Save - verify it's there @ load
		+ Ships with unicode chars in metadata, show well in dialog: Désirée Москва
			+ Load ship
			+ New ship
			+ Load .shp ship

+ Grid: highlight vertical center guide
	+ Test with odd ship width

+ Edit menu: Flip Horizontal, Vertical
	+ Buffer2D::Flip(...)
		+ Unit tests
	+ Ropes layer's buffer becomes a class, so it also has Flip()
		+ Unit tests
		+ Redo:
			+ LayerElements.h contains all layers' elements
			+ RopeLayerBuffer.h is the buffer
			+ Layers.h becomes smaller
	+ Undo: flip again
		+ New Undo form:
			+ Controller::RestoreLayer/Region: "...ForUndo"
				+ Don't set model dirtyness
			+ Controller::Flip + Controller::FlipForUndo
				+ Templated helper
					+ In undo mode: don't set model dirtyness, and don't push undo entry
		! Always do UploadVisualization+RefreshView however, as UndoStack can't do that (not all undo's must refresh viz)

+ Line tool:
	+ Settings: size
	+ Structural
	+ Electrical
		+ RAII Mend
		+ Do different algo for line tracing, to ensure pixels touch each other on the side
			+ Both at eph and non eph
			+ Not really needed - make "HUll" flag to turn or or off for structural, unused in Electrical
		+ Do not write on empty structural pixels
			+ Both at eph and non eph
			+ Verify engagement & subsequent drawing work fine (engage yes but no draw)
				+ Verify also at ElectricalPencil
		+ Dashed line overlay
			+ smoothstep and color between dashes
			+ Scissor dashed line
			+ Nail down pixel length/multiple
	+ Refactor line drawing call in LineTool as it's repeated twice
		+ Make helper
		+ Use it all all places
	+ Shift lock

+ Finalize design of Ropes layer
	! Spec:
		! Material Strategy: in Structural DB, separate palette tree - does NOT require current "ropes" to be marked as "legacy"
		! Element = start, end, StructuralMaterial *, renderColor
		! Legacy: StructuralMaterial=Ropes, RenderColor=color
		! ShipBuilder: StructuralMaterial=from ropes palette, RenderColor=from material
	+ Impl:
		+ Structural DB: separate palette tree
			+ Script
			+ MaterialsDB			
		+ Layers
		+ Legacy Deserialization
		+ ShipFactory
		+ Test
		+ SB::MaterialsPalette:
			+ Templated on layer - Material comes from TypeTraits
		+ LayerPanel for Rope
		+ New Ropes Layer workflow
		+ Test
		+ WorkbenchState		
		+ Pencil Tool
			+ View::CircleOverlay
				+ Shader
			+ Tool visualizations:
				+ Superimposed states:
					+ Overlay, at:
						+ cctor
						+ dctor
						+ MouseMove
						+ NOT at down/up X 2
					+ Engagement (i.e. line), at:
						+ Down x 2: engage if OK (if Model::IsRopeEndpointAllowed)
						+ Up x 2: disengage if engaged
						+ MouseMove: if engaged
			+ DoEdit
			+ CommitAndStopEngagement
				+ Undo
			+ ModelController::TempVisualization
		+ ModelController::Visualization
		+ ModelController::RestoreRopesForEphViz takes whole orig layer
		+ No check for end engagement
		+ IsApplicable: also ship rect
		+ View::RopesLayer
			+ Line OpenGL settings
			+ Upload straight away, no storage
			+ Render: before or after depending on primary layer
			+ Line width
			+ @Vertex-make-and-upload: Offset vertex to center of {1,1} ShipSpace rect
		+ Mouse released outside of window - while mouse is captured - does not nuke tool
			+ Note: this is a problem with the other tools as well
			+ Fix @ MainFrame::OnWorkCanvasXXXUp
		+ No temp visualization when mouse outside of coords - or simply, when mouse coords are not applicable
		+ Test
		+ "Move endpoint" mode
			! Spec: when button down (engagement check) is over existing endpoint, then start point is other
			+ Impl:
				+ Overlay:
					- If outside ship rect: RED
					- Else if engaged: check if OK to release 
						- May release only if there's no other rope endpoint at that position
					- Else (!engaged): check if OK to engage
						- Always
				+ StartEngagement:
					- If outside ship rect: NO
					- Else: check if OK to engage
						- Always
				+ EndEngagement: do action:
					- If outside ship rect: NO
					- Else: check if OK to release
						- May release only if there's no other rope endpoint at that position
			+ Test		
		+ DeSerialization
			+ Unit tests
		+ Opacity
			+ Shader: add param
		+ Test pencil: L and R buttons
		+ Remove Clear material from Ropes palette
			+ Remove checks from pencil, as matrial can never be clear
		+ Eraser Tool:
			! R button does the same as the L button (same as in structural/electrical)
			! No engagement - at L down we do the same as with temp viz
				! And we don't even ask ModelController, always EraseRopeAt(ForEphViz)
			+ Rethink: possibilities:
				+ No eph viz (w/deleted rope)
				+ Overlay gives feedback (red when won't delete anything)
				+ If we go for it:
					+ Remove ...ForEphViz method from ModelController
					+ Remove mHasEphemeralVisualization - et al
	+ New materials:
		+ Chains			
			+ For noise: consider adding new StructuralMaterial property: strain_threshold_fraction, default = 0.5
				+ Material
				+ Springs::UpdateForStrains:
					+ Springs::mBreakingElongationBuffer: it's buffer of two-float struct, BreakingElongation and StrainThresholdFraction
				+ Set at Chains material
				+ Test Chains
				+ Test other materials for no changes to strain threshold
			+ Rustyness
			+ Verify properties look'n'feel (tension)
		+ "Rubber Band"
			+ Sounds:
				+ Stress
				+ Break
				+ Underwater (above X 2)
				+ Destroy (copy from break, above- and under-water)				
			+ Create material
				+ See water intake
		+ Aluminium Chain
		+ "Strong" variants for all rope sub-categories
			+ In same category, but different sub-category (e.g. "Iron Chains" and "Iron Chains Strong" - see where we've put "Hull"); only strength (and possibly stiffness) changes
