- Gist:
	- Code organization:
		- ShipBuilderLib project, slave of FloatingSandbox project
		- ShipBuilder project, top-level project for standalone SB UI
			- For testing ShipBuilder alone
			- Just MainApp basically
		- All in separate ShipBuilder namespace
	- Own frame for UI
	- Model, View, Controller architecture
	- Reuses existing ResourceHelper, only need (at this moment) for separate resource directory and method is Shaders ("Game" and "ShipBuilder")
	- On the "structure: pixels vs triangles", Wreno says fine to edit in pixel mode, and allow user to eventually _view_ also in triangle mode (but not necessarily edit)
	- On the size: Wreno says "no fixed sized, allow whole world"

- Architecture:

	- MainFrame: IUserInterface
	  |------------------------------>View
	  |-------> Controller/Tools		    
		    |---->ModelController
			  |---->Model
			  |------------------------>View

	- MainFrame: owns toolboxes, etc.
		- Owns Controller and View
		- Very thin, calls into Controller for each high-level interaction (e.g. SelectTool(.), OnWorkbenchStateChanged(.))
		- Implements IUserInterface with interface required by controller, e.g. UI state changes, mouse capture, undo stack visualization
		- Owns WorkbenchState
			- Candidate for saved settings
			- Contains foreground and background materials, and settings for all tools
	- Controller
		- Owns ModelController, takes reference to View
		- Main Frame calls into Controller for each user interaction, including button clicks
			- Controller->Main Frame callbacks via IUserInterface
		- Maintains UI state (e.g. grid toggle, visible layers), instructing View
		- Maintains interaction state, implemented via Tools
		- Owns SelectionManager pseudo-tool
		- Owns ClipboardManager pseudo-tool
	- ModelController
		- Owns Model, takes reference to View
		- Implements all interactions and algorithms (e.g. pencil, line, flood, paste, etc.) and uploads resulting changes from Model into View
		- Implements ship load/save logic, populating/reading Model
		- Maintains Undo stack, and orchestrates undo stack visualization with IUserInterface
	- Model
		- All data, (almost) no operations (anemic), fully exported
		- Modified by ModelController
		- Knows nothing about view
		- IsDirty flag
	- View
		- Rendering of ship, all layers
		- Rendering of tool interactions (e.g. marching ants, squares, etc.)
		- Fully OpenGL
	- Tools
		- Implement state machines for interactions, including visual notifications (marching ants, paste mask, etc.)
		- Take references to WorkbenchState and SelectionManager (at tool initialization time)
			- SelectionManager so that Selection tool can save selection to it
		- Receive input state events from Controller, and notifications of WorkbenchState changed
		- Take references to View and ModelController
		- Modify Model via ModelController
		- Instruct View for tool interactions, e.g. tool visualizations (lines, paste mask, etc.)
		- Have also reference to IUserInterface, e.g. to capture/release mouse, visualize Undo stack

----------------------------------------------------------------------------------------------------------

- Workflows:
	- Create New Ship (@menu, @file panel)
		- GameController::CreateNew()
	- Create New Ship From TExture (@menu, @file panel)
		- GameController::CreateNewFromTexture()
	- Load Ship (@menu, @file panel)
		- GameController::Load()

- UI:
	- Controls:
		+ Button to save and go back to game (!StandaloneMode)
		+ Button to quit and go back to game (!StandaloneMode)
		- Button to Save (acts also as SaveAs for first save; menu however has also separate SaveAs)
		- Undo stack
		- Error (message) notification(s)
		- Add electrical/texture/ropes layer
		- Button to open ShipMetadata dialog
	- StatusBar:
		- Material under cursor
			- Polled from Model by Tools (pencil, drop, ...) and communicated to IUserInterface

= MainFrame:
	+ Created by game MainFrame at initialization, but kept hidden
	+ Switching between two frames: 
		+ MainFrame owns ShipBuilder::MainFrame, ShipBulder::MainFrame takes std::function(...ship file path...) "ReturnToGame" in cctor
			+ Latter may be null for stand-alone test executable
		+ Switch implemented via:
			- Game->ShipBuilder:
				- Create New Ship...
					- ::MainFrame::SwitchToShipBuilderForNewShip:
						- SB::MainFrame->OpenForNewShip()
							- Controller->CreateNewShip()
								- ModelController::CreateNew()
				- Edit This Ship...
					- ::MainFrame::SwitchToShipBuilderForCurrentShip:
						- SB::MainFrame->OpenForShip(ship file path)
							- Controller->LoadShip(ship file path)
								- ModelController::Load()
			- ShipBuilder->Game:
				- Quit and Return:
					- return-to-game-functor(std::nullopt)
				- Save and Return:
					- SB::MainFrame: SaveDialog -> filename or cancel operation
						- Controller->SaveShip(ship file path)
						- ::MainFrame::SwitchFromShipBuilder(ship file path)
				- ::MainFrame::SwitchFromShipBuilder(optional ship file path)
					- If file path: GameController->ResetAndLoadShip(this ship file path)
					- else: GameController->ResetAndLoadShip(current ship file path)

	- Panning is via "losse" scrollbars around canvas
		- For testing, requires Edit->Ship Size
			- For now: just add and then reduce, in circle, with static member
		- Their range & properties (& position==thumb) need to be updated at:
			- glCanvas resize
			- Zoom changes
			- Pan changes (including keys)
			- WorkSpace resize (i.e. image resize)
		- Scrollbars recalculated via private MainFrame::RecalculatePanning, which is invoked by:
			+ Self, @ glCanvas resize
			- Controller, @ Zoom, Pan, and WorkSpace resize - via IUserInterface
	+ Layers toolbar:
		+ Rename
		+ MainFrame and Controller logic:
			+ Move primaryLayer from ModelController to Controller
			+ Controller::NewXYZLayer/SetXYZLayer(LayerType/content) => Model::... => Model::mLayerPresenceMap[]
				+ Model::HasLayer(LayerType) => ModelController::GetModel()
			! UI consistency rules:
				! Things enabled if model has layers (Model::HasLayer(LayerType))
					! New, Load: always [nop]
					! Delete, Save: if HasLayer
					! Slider: only enabled if > 1 layers
					! Toggle button itself: if HasLayer
			+ Events rearc:
				+ Primary button: set in Controller, then ReconciliateUIWithPrimaryLayerSelection
					+ Other toggle buttons (radio)
					+ Set toolbar panel visibility
						+ Have array with panels
							+ Ropes toolbar: tools, no swath
							+ Texture toolbar: empty
				+ ReconciliateUIWithLayerPresence()
					+ Toggle button
					+ Delete, Save
					+ Slider
			+ Dirtiness
				+ Framework
				+ New button - w/dirty check for asking 
				+ Open button - w/dirty check for asking
				+ Save button - enabled only if dirty					
		+ UI:
			+ Redo with buttons
			+ Do icons for layers

	= Impl:
		- Click-And-Draw
			- Complete ViewModel:
				= Zoom
					= From MainFrame: MouseWheel and +/-
				- Cam
					- From MainFrame: scrollbars
					- TODO: calc'ns
				- Work area size
					- TODO: who tells View? If it needs to know...
			- Rendering of texture

	- Misc TODO's:
		- Toolbar:
			- Untoggle other buttons when one tool is toggled (i.e. radio behavior)
				- @ ReconciliateUIWithSelectedTool
		- Nuke test shader: shader file, relative ShaderTypes
		- App icons (whole "Resources" folder)
		- Preferences:
			- New ship size
			- ...all tools' settings...
			- TODO: spec
		- Inherits FullScreen state and shares state changes (so, for example, if exits full screen in ShipBuilder, also Game has exited full screen)
			- How to share state changes? 
				- FullScreenManager class, shared_ptr in both
				- Looked at at each Game<->ShipBuilder switch by receiver

- StatusBar:
	- Own class
	- Areas:
		- Canvas:
			- Coords and icon
			- Selection size and icon
			- WorkSpace size and icon
		- Ship:
			- Coord and icon
			- Ship size and icon

- Controller:

- ModelController:
	- static factory methods:
		+ CreateNew
		- Load(shipFilePath)

- Tools:
	- BaseTool:
		- Stores all protected references passed from cctors: IUserInterface, ModelController, View, SelectionManager
		- Abstract methods from game - but all pure
	- All tools:
		- Pencil
			- Settings: Size
		- Eraser
			- Settings: Size
		- Flood
		- Selection
		- Sample
		- Line
		- Rectangle
			- Settings: FillWithFore|FillWithBack|NoFill; Size
		- Ellipses
		- Mass changer
	- SelectionManager pseudo-tool:
		- Maintains current selection
		- Not really a tool but a pseudo-tool
		- Takes View so that it can instruct it to render marching ants
			- Is not responsible for drawing of temporary selection while the user is making it, that is the Selection tool
		- Read by ClipboardManager pseudo-tool to make clip
	- Selection tool:
		- Implements selection interaction and rendering of visual feedback *during the interaction only*
		- Takes SelectionManager ref (like all tools, part of the ITool interface), and populates it upon confirmation of selection made
	- ClipboardManager pseudo-tool:
		- Maintains clip
		- Implements operations: Copy, Cut, Paste
			- TODO: who should be responsible for the interactions during Paste? See Photoshop and Paint
		- Talks with IUserInterface to enable/disable menus

- RenderContext:
	- Single-threaded
	- Initializes on same canvas that main frame initializes on
		- So needs to be passed to SB::MainFrame's cctor
		- TODO: after or before? Better before for less chance of side effects?
			- Ideally other context is removed before new one is set
			- See if can move global GameOpenGL initialization outside of Game RenderContext and into ::MainFrame initialization, before both
	- Renders synchronously, on-demand via SB::MainFrame::OnPaint()
		- Except when we need animated tools, e.g. ants walking: for these we set a timer (in the order of 100's of ms) during the duration
		  of the tool
	= ViewModel:
		+ Terminology:
			+ WorkSpace: has the pixel size of the structure (equivalent of ::World)
			+ WorkSpaceCoordinates (type @ ShipBuilderTypes)
			+ DisplayLogical: has the logical display (window) size (equivalent of ::Logical)
			+ DisplayLogicalCoordinates: the logical display coordinates (type @ ShipBuilderTypes)
			+ DisplayPixel: has the pixel display (window) size (equivalent of ::Pixel)
			+ DisplayPixelCoordinates: the pixel display coordinates (type @ ShipBuilderTypes)
		+ World coords is model pixel coords, i.e. WorkSpace
		= Tells outside world of pan extent (for scrollbar width setting)
			- Based on calc'd pixel (display) coords of four sides of work area

- WorkbenchState
	+ Independent from model - exclusively tools-related settings
		+ So no need to reset/change/update at new model creation
	= cctor: (MaterialsDB, SB::PreferencesManager)
		+ FW and BG materials: always "defaults" from MaterialsDB
		- other settings: loaded from SB::PreferencesManager

- Controls:
	+ BitmapCheckbox (see if * exists) (@UIControls)
		! We'll re-use it for ShipLoadDialog
	- PopupButton (@UIControls)
		! We'll use it for popup tools
		- Takes callback for push, which takes wxPoint
		- Ideantical to BitmapButton, except for arg of callback
	= MaterialsPalettePicker (@ShipBuilder): wxPanel
		+ Templated on material type (Structural or Material)
		! MainFrame owns two instances: Structural and Electrical			
		! Column 1: scrollable vertical panel with bitmap buttons for selecting category
		! Column 2: scrollable panel with rows and cols for selected category's materials		
		! Opened on demand when clicking on Foreground/Background PopupButtons
			- And then sets focus on material
		- Impl:
			+ Rearc:
				+ ShipTexturizer takes MaterialsDB in cttor - and not ResourceLocator
					+ Validates here that all exist
				+ Nuke validation
			+ Materials/DB changes:
				+ Each material has new PaletteCoordinates:
					+ Category ("Metal", "Wood", ...) (plain string, no enum)
					+ SubCategory ("Iron", "Iron Hull", ...) (plain string, no enum)
					+ MaterialOrdinal (ordinal in SubCategory)
				+ Then json has PaletteStructure:
					+ List of categories, in order of presentation
					+ For each category: list of sub-categories, in order of presentation
				+ Materials' PaletteCoordinates are verified to be in PaletteStructure at MaterialsDB load time
					+ Including ordinals' conflicts
					+ For each material, as they are deserialized
						+ Invert order: palette structure first
				+ Multi-key materials: automagically increase ordinal at Material::Parse
				+ Make sure each cat & sub-cat has a material
				+ Complete structural json palette
				+ Also do at Electrical
				+ Python script
			+ GameController exposes MaterialsDB const &
			+ ShipTexturizer (and StrengthRandomizer): owned by GameController (like MaterialDB) and passed down to ShipBuilder
				+ ShipBuilder takes them in cctor
					+ No more settings methods for texturizer & randomizer
				+ Then, ShipTexturizer exposed by GameController
			+ SB::MainFrame cctor
			+ SB::MainApp loads MaterialsDB & ShipTexturizer
			+ ShipTexturizer exposes new instance method that does color-blending of one tile of material texture: (size, material &) -> rgbaImage
				+ This method also needs to take custom texturization settings, but for material swaths we pass nullopt (using shared settings then)
			+ Make Fore & Back swaths in MainFrame
				+ Do WorkbenchState (*)
				+ CreateToolbar(): create internally two panels (structural and electrical, members of MainFrame), each with own pair of swaths
				+ Implement SB::MainFrame::SyncWorkbenchStateToUI for swaths, using ShipTexturizer method to make bitmaps and populate in swaths
					+ Do preloaded "null" bitmap
					+ Update tooltip for swaths with material name
				+ Do also electrical
			+ cctor(MaterialsDB const &, GameTypes::MaterialLayerType == TemplateArg, ...)
				= Build all panels as grids of static bmps (kinda like BitmapCheckbox)
					+ Include "empty" category for no-brush case
					+ Store sizer for "hiding tricks" to ensure one panel at a time
					+ Fix margin/scrollbar thing
					+ V and H scrollbars at each category panel
						+ With adjustment @ Open()					
			+ Open(wxPoint, wxRect referenceArea (absolute rect of work canvas), ShipBuilderTypes::MaterialPlaneType(Fore|Back), Material const *)
				+ Positionate and resize self
				+ Hides all category panels except the one
				+ Begins selection with the one from WorkbenchState
					+ Vector of vectors of buttons, each with material in objectdata
			+ Category selection:
				+ Select panel
			+ On selection:
				+ Fire event - one of Structural|Electrical, with (TMaterial *, MaterialPlaneType) args
				+ Close
				+ SB::MainFrame receival:
					+ set material in WorkbenchState
					+ start OnWorkbenchStateChanged cascade, i.e. call SyncWorkbenchStateToUI
			+ CategoryPanel:
				+ Make it so that width of cols is fixed, not dictated by labels
					+ Name: wrap
					+ Shorter data strings
				+ Redo cat panels as simple panels, all embedded in a wxScrolled ("categoryPanelsContainer") that is immediate child of root
					+ With HSizer used for hiding
					+ Fix: category panels don't want to grow H
				+ Area with properties of material under cursor
					+ Hook mouse enter/leave event on each button
			+ See if can subclass MaterialPaletteCategoryPanel to prevent unnecessary Layout()
				+ LockLayout(bool lock=true)
			+ Use wxWindowUpdateLocker instead of Freeze/Thaw
			+ Test also Electrical
				+ Do View toolbar ("Layers Toolbar") *
				+ Finish property grid(s)
			- Material descriptions
				- json + Material class
				- Text area underneath property grid
					- Methods: "SetMaterialProperties" instead of "SetMaterialPropertyGrid"			

- Ship file format:
	- Min FS version (.shp, .shp2)
		- Ideally it should be a "set" of versions, including the Materials' DB versions which live in the json so to be easily editable manually
	- "File lock" which disallows editing
		- Password from user; salted -> Hash in file
		- Verify hash matches when editing
	- Also includes sounds
		- Extract from other "TODO" .txt file

- Misc:
	- Localization:
		- See if can do separate extraction into separate file, which then is loaded at all times by LocalizationManager together with the other one 
	- Ruler: pick a scale (pixels to meter of original ship), then you choose how long the ruler
		- L shaped: horizontal and vertical
		- Ruler sticks to the canvas
		- Only one ruler at a time
	- Texture Generator for ship canvas:
		- Makes larger image, with bilinear interpolation with alpha blending
			- Ain't that what we've got already for the auto-texturizer?
	- Selectable backgrounds
	- See if it takes so long to initialize SB::MainFrame that we need IProgress
	- TO-SPEC:
		- What to do with background music when switching back and forth?

