- Gist:
	- Code organization:
		- ShipBuilderLib project, slave of FloatingSandbox project
		- ShipBuilder project, top-level project for standalone SB UI
			- For testing ShipBuilder alone
			- Just MainApp basically
		- All in separate ShipBuilder namespace
	- Own frame for UI
	- Model, View, Controller architecture
	- Reuses existing ResourceHelper, only need (at this moment) for separate resource directory and method is Shaders ("Game" and "ShipBuilder")
	- On the "structure: pixels vs triangles", Wreno says fine to edit in pixel mode, and allow user to eventually _view_ also in triangle mode (but not necessarily edit)
	- On the size: Wreno says "no fixed sized, allow whole world"

- Architecture:

	- MainFrame: IUserInterface
	  |------------------------------>View
	  |-------> Controller/Tools		    
		    |---->ModelController
			  |---->Model
			  |------------------------>View

	- MainFrame: owns toolboxes, etc.
		- Owns Controller and View
		- Very thin, calls into Controller for each high-level interaction (e.g. SelectTool(.), OnWorkbenchStateChanged(.))
		- Implements IUserInterface with interface required by controller, e.g. UI state changes, mouse capture, undo stack visualization
	- Controller
		- Owns ModelController, takes reference to View
		- Main Frame calls into Controller for each user interaction, including button clicks
			- Controller->Main Frame callbacks via IUserInterface
		- Maintains UI state (e.g. grid toggle, visible layers), instructing View
		- Maintains interaction state, implemented via Tools
		- Owns SelectionManager pseudo-tool
		- Owns ClipboardManager pseudo-tool
		- Owns WorkbenchState
			- Candidate for saved settings
			- Contains foreground and background materials, and settings for all tools
	- ModelController
		- Owns Model, takes reference to View
		- Implements all interactions and algorithms (e.g. pencil, line, flood, paste, etc.) and uploads resulting changes from Model into View
		- Implements ship load/save logic, populating/reading Model
		- Maintains Undo stack, and orchestrates undo stack visualization with IUserInterface
	- Model
		- All data, (almost) no operations (anemic), fully exported
		- Modified by ModelController
		- Knows nothing about view
		- IsDirty flag
	- View
		- Rendering of ship, all layers
		- Rendering of tool interactions (e.g. marching ants, squares, etc.)
		- Fully OpenGL
	- Tools
		- Implement state machines for interactions, including visual notifications (marching ants, paste mask, etc.)
		- Take references to WorkbenchState and SelectionManager (at tool initialization time)
			- SelectionManager so that Selection tool can save selection to it
		- Receive input state events from Controller, and notifications of WorkbenchState changed
		- Take references to View and ModelController
		- Modify Model via ModelController
		- Instruct View for tool interactions, e.g. tool visualizations (lines, paste mask, etc.)
		- Have also reference to IUserInterface, e.g. to capture/release mouse, visualize Undo stack

----------------------------------------------------------------------------------------------------------

- UI:
	- StatusBar:
		- Material under cursor
			- Polled from Model by Tools (pencil, drop, ...) and communicated to IUserInterface

= MainFrame:
	+ Created by game MainFrame at initialization, but kept hidden
	- Inherits FullScreen state and shares state changes (so, for example, if exits full screen in ShipBuilder, also Game has exited full screen)
		- How to share state changes? 
			- FullScreenManager class, shared_ptr in both
	= Switching between two frames: 
		+ MainFrame owns ShipBuilder::MainFrame, ShipBulder::MainFrame takes std::function(...ship file path...) "ReturnToGame" in cctor
			+ Latter may be null for stand-alone test executable
		= Switch implemented via:
			= MainFrame::SwitchToShipBuilder: invoked by MainFrame when user switches to ship builder
				- Stops game loop
					- Ideally not just "pause", but full "stop"
						- "pause" is inadequate for a number of reasons:
							- it shows "Paused"
							- if we're already paused, we'll go back to unpaused
							- ...
						- GameController::Stop(), resumed only via call that takes ship
							- Same mechanism also becomes used by ::MainFrame
				+ Hides self
				= Invokes ShipBuilder::MainFrame::Open(...ship file path...)
					+ Which makes self the top frame
			+ ShipBuilder::MainFrame::ReturnToGame: invoked by ShipBuilder::MainFrame when user returns to game
				+ Hides self
				+ Invokes std::function(std::optional<...ship file path...>) "ReturnToGame"
					+ Which makes self the top frame
	- Panning is via "losse" scrollbars around canvas
		- Their range & properties (& position==thumb) need to be updated at:
			- glCanvas resize
			- Zoom changes
			- Pan changes (including keys)
			- WorkSpace resize (i.e. image resize)
		- Scrollbars recalculated via private MainFrame::RecalculatePanning, which is invoked by:
			- Self, @ glCanvas resize
			- Controller, @ Zoom, Pan, and WorkSpace resize - via IUserInterface
		- Try to make it so that if scrollbars really end up disappearing, we don't resize the glCanvas
	= Impl:
		- Integrate with FloatingSandbox:
			+ ::MainFrame: menu entry for invoking "new"
				+ Call ::MainFrame::SwitchToShipBuilder
			= SB::MainFrame: Save and Go Back
				+ Only if !StandAlone
				- Button 
				+ File menu item
				+ Call SB::MainFrame::SwitchBackToGame, which hides self and calls functor
					+ Functor does not take opt: always has a path
			= SB::MainFrame: Quit and Go Back
				+ Only if !StandAlone
				+ File menu item
				= Same return path as Save and Go Back, but with original ship path
					- TODO: when do we know original ship path?
			- Nail down what are the interface and the args between Game and ShipBuilder
				- Ship: only path, never in-memory - to avoid risk of badly-saved ship
					- Eventually save to temp file - or better, file in temp directory (so doesn't fill up disk)
				- Open(...ship file path...)
		- Click-And-Draw
			- Complete ViewModel:
				- Zoom
					- From MainFrame: MouseWheel and +/-
				- Cam
					- From MainFrame: scrollbars
					- TODO: calc'ns
				- Work area size
					- TODO: who tells View?
			- Rendering of texture

	- Misc TODO's:
		- GameController::Stop/Restart-with-ship-file-path:
			- GameWallClock
			- TODOHERE
		- StatusBar:
			- Icon for coords (like MSPaint)
		- Nuke test shader: shader file, relative ShaderTypes
		- Frame icons (whole "Resources" folder)

- Controller:
	- Methods to instantiate ModelController: 
		- CreateNewShip()
		- LoadShip(..)
		- TODOHERE: need to refresh tool - shouldn't be better to nuke and re-create Controller altogether?

- ModelController:
	- static factory methods:
		- CreateNew
		- CreateFromShip(shipFilePath)

- Tools:
	- BaseTool:
		- Stores all protected references passed from cctors: IUserInterface, ModelController, View, SelectionManager
	- TODO: "pencil" tool
	- TODO: "smaple" tool
	- SelectionManager pseudo-tool:
		- Maintains current selection
		- Not really a tool but a pseudo-tool
		- Takes View so that it can instruct it to render marching ants
			- Is not responsible for drawing of temporary selection while the user is making it, that is the Selection tool
		- Read by ClipboardManager pseudo-tool to make clip
	- Selection tool:
		- Implements selection interaction and rendering of visual feedback *during the interaction only*
		- Takes SelectionManager ref (like all tools, part of the ITool interface), and populates it upon confirmation of selection made
	- ClipboardManager pseudo-tool:
		- Maintains clip
		- Implements operations: Copy, Cut, Paste
			- TODO: who should be responsible for the interactions during Paste? See Photoshop and Paint
		- Talks with IUserInterface to enable/disable menus

- RenderContext:
	- Single-threaded
	- Initializes on same canvas that main frame initializes on
		- So needs to be passed to SB::MainFrame's cctor
		- TODO: after or before? Better before for less chance of side effects?
			- Ideally other context is removed before new one is set
			- See if can move global GameOpenGL initialization outside of Game RenderContext and into ::MainFrame initialization, before both
	- Renders synchronously, on-demand via SB::MainFrame::OnPaint()
		- Except when we need animated tools, e.g. ants walking: for these we set a timer (in the order of 100's of ms) during the duration
		  of the tool
	- ViewModel:
		+ Terminology:
			+ WorkSpace: has the pixel size of the structure (equivalent of ::World)
			+ WorkSpaceCoordinates (type @ ShipBuilderTypes)
			+ DisplayLogical: has the logical display (window) size (equivalent of ::Logical)
			+ DisplayLogicalCoordinates: the logical display coordinates (type @ ShipBuilderTypes)
			+ DisplayPixel: has the pixel display (window) size (equivalent of ::Pixel)
			+ DisplayPixelCoordinates: the pixel display coordinates (type @ ShipBuilderTypes)
		- Knows about work area (i.e. structure) size, for panning calculations
			- TODO: or not? Whoever needs panning calc'ns might get away with ScreenToWorld/etc., knowing WorkSpace size
		- World coords is model pixel coords
		- Tells outside world of pan extent (for scrollbar width setting)
			- Based on calc'd pixel (display) coords of four sides of work area

- UI architecture:
	- Topmost toolbar:
	- Above main working area: "tab-like" buttons for layers, including "+" to add layers, and horizontal sliding bar for transparency of currently-selected layer
		- Or as Wreno: 1 slider + N checkboxes for the "other layers" to see on top of currently-edited layer, with that transparency
	- Left toolbar: tools:
		- Changes content depending on currently-selected layer
		- Structure layer:
			- Pencil
			- Mass changer
	- Main work area: glCanvas with "losse" scroll bars

- Controls:
	- BitmapCheckbox (see if * exists) (@UIControls)
		! We'll re-use it for ShipLoadDialog
	- PopupButton (@UIControls)
		! We'll use it for popup tools
		- Takes callback for push, which takes wxPoint
	- MaterialsPalette (@ShipBuilder)
		- Column 1: scrollable vertical panel with bitmap button for selecting category
		- Column 2: scrollable panel with rows and cols for selected category's materials
		- Materials/DB changes:
			- For each category, must have one selected as the "header" (shown in column 1)
			- TODO: see if can keep rows and cols, or refactor it - we still want to be able to generate template image
		- Opened on demand when clicking on Foreground (or "TODO1") and Background (or "TODO2") PopupButtons, taking material as argument
			- And then sets focus on it

- Ship file format:
	- Min FS version (.shp, .shp2)
		- Ideally it should be a "set" of versions, including the Materials' DB versions which live in the json so to be easily editable manually
	- "File lock" which disallows editing
		- Password from user -> Hash in file
	- Also includes sounds
		- Extract from other "TODO" .txt file

- Misc:
	- Ruler: pick a scale (pixels to meter of original ship), then you choose how long the ruler
		- L shaped: horizontal and vertical
		- Ruler sticks to the canvas
		- Only one ruler at a time
	- Texture Generator for ship canvas:
		- Makes larger image, with bilinear interpolation with alpha blending
			- Ain't that what we've got already for the auto-texturizer?
	- Selectable backgrounds
	- TO-SPEC:
		- What to do with background music when switching back and forth?

