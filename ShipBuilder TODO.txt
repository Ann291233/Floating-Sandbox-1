https://gamejolt.com/x/permalink/comment/11730705

+ Mattia makes ship
	+ YouTube
	+ GameJolt post

+ At selection of new primary layer (in Controller): select first tool
	+ Or remember tool per-layer
		+ Have array for all layer types (int) storing tool type
		+ Controller::SetTool:
			+ Store this tool as last tool of primary layer
		+ Controller::SetPrimaryLayer:
			+ After switching UI: set last tool for new primary layer
	+ Fix:
		+ New code creates tool (via SetTool invoked to set last tool for layer) while tool is "suspended", @ NewLayer & RemoveLayer, when we set PrimaryLayer
		+ SetTool, SetPrimaryLayer, NewLayer, RemoveLayer: they all call InternalSetTool & InternalSetPrimaryLayer

+ Eraser square?
	+ See paint: has it
	+ View: EraserSquareOverlay

+ EraserSquareOverlay -> RectOverlay
	+ Rename
	+ Try it also with normal pencil

+ Pencil electrical: not on empty structural
	+ Eph viz: red rect overlay when on empty
		+ Shader
	+ Do action: no fill when on empty

+ No flood for electrical layer
	+ Simply remove specialization
	+ Also remove ModelController::Flood specialization

+ Flood: settings: adjacent

+ UnderConstructionDialog
	+ Do at remaining layer buttons

+ Send for testing

= Finalize design of Ropes layer
	! Spec:
		! Material Strategy: in Structural DB, separate palette tree - does NOT require current "ropes" to be marked as "legacy"
		! Element = start, end, StructuralMaterial *, renderColor
		! Legacy: StructuralMaterial=Ropes, RenderColor=color
		! ShipBuilder: StructuralMaterial=from ropes palette, RenderColor=from material
	= Impl:
		+ Structural DB: separate palette tree
			+ Script
			+ MaterialsDB			
		+ Layers
		+ Legacy Deserialization
		+ ShipFactory
		+ Test
		+ SB::MaterialsPalette:
			+ Templated on layer - Material comes from TypeTraits
		+ LayerPanel for Rope
		+ New Ropes Layer workflow
		+ Test
		+ WorkbenchState		
		+ Pencil Tool
			+ View::CircleOverlay
				+ Shader
			+ Tool visualizations:
				+ Superimposed states:
					+ Overlay, at:
						+ cctor
						+ dctor
						+ MouseMove
						+ NOT at down/up X 2
					+ Engagement (i.e. line), at:
						+ Down x 2: engage if OK (if Model::IsRopeEndpointAllowed)
						+ Up x 2: disengage if engaged
						+ MouseMove: if engaged
			+ DoEdit
			+ CommitAndStopEngagement
				+ Undo
			+ ModelController::TempVisualization
		+ ModelController::Visualization
		+ ModelController::RestoreRopesForEphViz takes whole orig layer
		+ No check for end engagement
		+ IsApplicable: also ship rect
		+ View::RopesLayer
			+ Line OpenGL settings
			+ Upload straight away, no storage
			+ Render: before or after depending on primary layer
			+ Line width
			+ @Vertex-make-and-upload: Offset vertex to center of {1,1} ShipSpace rect
		+ Mouse released outside of window - while mouse is captured - does not nuke tool
			+ Note: this is a problem with the other tools as well
			+ Fix @ MainFrame::OnWorkCanvasXXXUp
		+ No temp visualization when mouse outside of coords - or simply, when mouse coords are not applicable
		+ Test
		- "Move endpoint" mode
			! Spec: when button down (engagement check) is over existing endpoint, then start point is other
			- Impl:
				- Overlay:
					- If outside ship rect: RED
					- Else if engaged:
						- TODO
					- Else (!engaged):
						- TODO
				- StartEngagement:
					- If outside ship rect: NO
					- Else TODOHERE
				- EndEngagement: do action:
					- If outside ship rect: NO
					- Else TODOHERE
			- Test		
		+ DeSerialization
			+ Unit tests
		- Eraser Tool
	- New materials:
		= Chains
			- Test properties
				- For noise: consider adding new StructuralMaterial property: strain_threshold_fraction, default = 0.5
					- Material
					- Springs::UpdateForStrains:
						- Springs::mBreakingElongationBuffer: it's buffer of two-float struct, BreakingElongation and StrainThresholdFraction
					- Set at Chains
			+ Rustyness
		- "~Elastic"
		- More chains of other metal types

	- New sounds:
		= "Chain":
			+ Material palette
			+ SoundController
			= Make sounds
				- Underwater
		- "~Elastic":
			- Material palette
			- SoundController
			- Make sounds


- Complete Load/Save/Model
	- Finalize storage of all other ship definition members in Model
	- Load/Save each of:
		- Electrical layer
			- Pure buffer			
		- Ropes layer
			- Pure buffer
		- Texture layer
			- Using DevIL lump, see https://github.com/DentonW/DevIL/blob/master/DevIL/src-IL/src/il_io.cpp#L2490
		+ PhysicsData
		- AutoTexturizationSettings

- Import/Export:
	- Structural:
		- Import from:
			- .png, .shp, .shp2 (load whole and throw away)
		- Export to .png
			- ShipDeSerializer:
				- SaveStructuralLayerImage(StructuralLayerBuffer const &, ...)
	- Electrical:
		- Import:
			- .shp, .shp2 (load whole and throw away)
		+ No export (can save .shp2 and import from there)
	- Ropes:
		- Import:
			- .shp, .shp2 (load whole and throw away)
		+ No export (can save .shp2 and import from there)
	- Texture:
		- Import:
			- .png
				- Ad-hoc code using ImageFileTools
			- .shp, .shp2 (load whole and throw away)
		- Export to .png (though quite useless at this moment)
			- Ad-hoc code using ImageFileTools
	- Notes:
		- Any import from .shp2 requires password

- New/Set/Remove layers:
	- New:
		- Make internal helper templated on LayerType, with all code
			- RAII tool stop/restart?
		- Additions:
			- Undo
	- Set:
		- Make internal helper templated on LayerType, with all code
		- Additions:
			- Undo
	- Remove:
		- Make internal helper templated on LayerType, with all code
		- Additions:
			- Undo

- Each time we StartTool() (e.g. at AddLayer, etc.) we end up refreshing modelcontroller's visualization and OpenGL visualization, twice

= Metadata edit workflow:
	+ ShipPropertiesEditDialog
	= Dialog::Open takes Controller &, Metadata const &, PhysicsProperties const &, etc.
		+ Pass bool HasTexture (to enable ArtCredits)
		+ opt<struct> mSessionData
		- Populates all controls
		- Flags each control as being not dirty
	- Editing a field flags it as being dirty
	= Ship name
		- TODO: nail down ship name change & file name change - VERIFY BELOW
			- MainFrame: compare output of MakeFilename() on new ship name with current filename, and if different && there is a current:
				- Ask rename
					- If yes:
						- Rename file (filesystem)
						- Change current
					- If no:
						- If has a current: clear current (and Save will become SaveAs)
						- If has no current: Save is already set to become SaveAs, we're OK
	+ Author(s)
	- Art Credits
		- Enabled only if HasTexture
		- ModelController: nuke ArtCredits upon texture removal? Or simply not cook it in final ShipDefinition?
		- At OK: populated only if HasTexture (though should be empty by then)
	+ Year Built
	- Edit Password
		- Extra condition on enabling OK button: no password, or two password fields match
		- Workflow:
			- TODOHERE
	- Description
		- Separate tab?
	- At OK:
		- For each of Metadata, PhysicsProperties, etc:
			- Check if any of this area's controls are dirty; if so:
				- Construct new Metadata, PhysicsProperties, etc.
					- Set optionals to nullopt if trimmer field is empty
				- Call Controller::ReplaceMetadata(&&), etc.
					- Which in turn invokes IUserInterface callback for refreshes, which do NOT reach edit dialog though
	- Tests:
		- Ships with unicode chars in metadata, show well in dialog: Désirée Москва
			- Load ship
			- New ship


- Resize workflow:
	+ Button - in Ship Settings panel, slightly separated from the File buttons
	- Click -> Dialog for Canvas Centering/Clipping -> Controller -> ...TODO...

- Other tools:
	- Line tool


- Undo stack visualization: underneath toolbar?
			
- App icons (whole "Resources" folder)

================================================================================================================================================================================

- Gist:
	- Code organization:
		- ShipBuilderLib project, slave of FloatingSandbox project
		- ShipBuilder project, top-level project for standalone SB UI
			- For testing ShipBuilder alone
			- Just MainApp basically
		- All in separate ShipBuilder namespace
	- Own frame for UI
	- Model, View, Controller architecture
	- Reuses existing ResourceHelper, only need (at this moment) for separate resource directory and method is Shaders ("Game" and "ShipBuilder")
	- On the "structure: pixels vs triangles", Wreno says fine to edit in pixel mode, and allow user to eventually _view_ also in triangle mode (but not necessarily edit)
	- On the size: Wreno says "no fixed sized, allow whole world"

- Architecture:

	- MainFrame: IUserInterface
	  |------------------------------>View
	  |-------> Controller/Tools		    
		    |---->ModelController
			  |---->Model
			  |------------------------>View

	- MainFrame: owns toolboxes, etc.
		- Owns Controller and View
		- Very thin, calls into Controller for each high-level interaction (e.g. SelectTool(.), OnWorkbenchStateChanged(.))
		- Implements IUserInterface with interface required by controller, e.g. UI state changes, mouse capture, undo stack visualization
		- Owns WorkbenchState
			- Candidate for saved settings
			- Contains foreground and background materials, and settings for all tools
		- Implements ship load/save logic, giving/getting whole ShipDefinition to/from ModelController
	- Controller
		- Owns ModelController, takes reference to View
		- Main Frame calls into Controller for each user interaction, including button clicks
			- Controller->Main Frame callbacks via IUserInterface
		- Maintains UI state (e.g. grid toggle, visible layers), instructing View
		- Maintains Undo stack (not individual entries), and orchestrates undo stack visualization with IUserInterface
		- Maintains interaction state, implemented via Tools
		- Owns SelectionManager pseudo-tool
		- Owns ClipboardManager pseudo-tool
	- ModelController
		- Owns Model, takes reference to View
		- Implements all interactions and algorithms (e.g. pencil, line, flood, paste, etc.), uploading resulting changes from Model into View,
		  and creating Undo stack entries		
	- Model
		- All data, (almost) no operations (anemic), fully exported
		- Modified by ModelController
		- Knows nothing about view
		- IsDirty tracking
	- View
		- Rendering of ship, all layers
		- Rendering of tool interactions (e.g. marching ants, squares, etc.)
		- Fully OpenGL
	- Tools
		- "Extensions" of Controller
		- Implement state machines for interactions, including visual notifications (marching ants, paste mask, etc.)
		- Take references to WorkbenchState (at tool initialization time)
		- Selection tool Take references to SelectionManager (at tool initialization time), so that it can save selection to it
		- Receive input state events from Controller, and notifications of WorkbenchState changed
		- Take references to View and ModelController
		- Modify Model via ModelController
		- Instruct View for tool interactions, e.g. tool visualizations (lines, paste mask, etc.)
		- Have also reference to IUserInterface, e.g. to capture/release mouse

----------------------------------------------------------------------------------------------------------

- Workflows:
	- Create New Ship (@menu, @file panel)
		- GameController::CreateNew()
	- Create New Ship From TExture (@menu, @file panel)
		- GameController::CreateNewFromTexture()
	- Load Ship (@menu, @file panel)
		- GameController::Load()

- Dirtyness:
	- Storage is at Model
		- Include metadata
	- Manipulated by Controller via ModelController methods
		- So Controller notifies IUserInterface

- UI Controls:
	+ Button to save and go back to game (!StandaloneMode)
	+ Button to quit and go back to game (!StandaloneMode)
	- Button to Save (acts also as SaveAs for first save; menu however has also separate SaveAs)
	- Undo stack
	- Error (message) notification(s)
		- StatusBar w/tooltip?
	+ Add electrical/texture/ropes layer
	- Button to open ShipMetadata dialog
	- Resize button (canvas resize)


- StatusBar:
	+ Own class
	- Try making it a wxPanel rather than a wxStatusBar
	- Cctor and Set(.) for UnitsSystem
		- From SB::MainFrame cctor
		- And store tools coords, ship size, etc. for re-populating on change	
	- Areas:
		- Canvas:
			- Coords and icon (x,y), w/meters/feet as well
			- WorkSpace size and icon (wxh), w/meters/feet as well
			- Selection/line/rect/etc. size and icon (wxh), w/meters/feet as well
			- Zoom (%)
				+ MainFrame: OnViewModelChanged calls a new ReconciliateUIWithViewModel(), which does:
					+ StatusBar: set zoom
					+ RecalculateWorkCanvasPanning
			- Material under cursor (for drop tool)
			- Warning icon (w/tooltip)

- Tools:
	! Most tools should pan when the (captured) mouse is outside of the canvas
		- Via BaseTool::ScrollIntoViewIfNeeded, which simply forwards to IUserInterface::ScrollIntoViewIfNeeded(display logical)
	+ Tool:
		+ Stores all protected references passed from cctors: IUserInterface, ModelController, View
		+ Same abstract methods from game - but all pure
	- All tools:
		+ Pencil (S, E)
			+ Settings: Size
		+ Eraser (S, E)
			+ Settings: Size
		+ Flood (S, E)
		- Sample
		- Line
			- ESC to stop 
		- Rectangle
			- Settings: FillWithFore|FillWithBack|NoFill; Size
			- ESC to stop
		- Selection
			- Implements selection interaction and rendering of visual feedback *during the interaction only*
			- Takes SelectionManager ref in its cctor, and populates it upon confirmation of selection made
		- Ellipses
		- Translate (aka move)
	- SelectionManager pseudo-tool:
		- Maintains current selection
		- Not really a tool but a pseudo-tool
		- Takes View so that it can instruct it to render marching ants
			- Is not responsible for drawing of temporary selection while the user is making it, that is the Selection tool
		- Read by ClipboardManager pseudo-tool to make clip
		- TODO: templated on layer type?
	- ClipboardManager pseudo-tool:
		- Maintains clip
		- Implements operations: Copy, Cut, Paste
			- TODO: who should be responsible for the interactions during Paste? See Photoshop and Paint
				- A different, unselectable tool?
		- Talks with IUserInterface to enable/disable menus

- RenderContext:
	- Single-threaded
	- Initializes on same canvas that main frame initializes on
		- So needs to be passed to SB::MainFrame's cctor
		- TODO: after or before? Better before for less chance of side effects?
			- Ideally other context is removed before new one is set
			- See if can move global GameOpenGL initialization outside of Game RenderContext and into ::MainFrame initialization, before both
	- Renders synchronously, on-demand via SB::MainFrame::OnPaint()
		- Except when we need animated tools, e.g. ants walking: for these we set a timer (in the order of 100's of ms) during the duration
		  of the tool
			- via an IUserInterface method, and another call to stop it ("SetAutoRender(bool)")
	+ ViewModel:
		+ Terminology:
			+ WorkSpace: has the pixel size of the structure (equivalent of ::World)
			+ WorkSpaceCoordinates (type @ ShipBuilderTypes)
			+ DisplayLogical: has the logical display (window) size (equivalent of ::Logical)
			+ DisplayLogicalCoordinates: the logical display coordinates (type @ ShipBuilderTypes)
			+ DisplayPixel: has the pixel display (window) size (equivalent of ::Pixel)
			+ DisplayPixelCoordinates: the pixel display coordinates (type @ ShipBuilderTypes)
		+ World coords is model pixel coords, i.e. WorkSpace
		+ Tells outside world of pan extent (for scrollbar width setting)
	- Primitives:
		+ Background text
		+ Structural RenderColor Texture
		- Electrical RenderColor Texture
		- Pseudo-cursor
			- One of many types; removed with a single call


- WorkbenchState
	+ Independent from model - exclusively tools-related settings
		+ So no need to reset/change/update at new model creation
	= cctor: (MaterialsDB, SB::PreferencesManager)
		+ FW and BG materials: always "defaults" from MaterialsDB
		- other settings: loaded from SB::PreferencesManager

= Ship file format:
	+ Fixed endianness
		+ See https://github.com/voidah/archive/blob/master/archive.h
	+ FS version
		+ Only used for warnings in case materials not found and cur version > file version
	- "File lock" which disallows editing
		! Password from user; salted -> Hash in Metadata
		! Verify hash matches when editing
		- Hash algo at ShipDeSerializer via static helper method
		- Workflows
			- Save: ShipDeSerializer::CalculatePasswordHash(password): +salt => hash (new GameType) => in metadata
			- ShipBuilder::Open and Game::EditInShipBuilder: After load, ShipDeSerializer::CalculatePasswordHash(password) => check with metadata
	- Also includes sounds
		- Extract from other "TODO" .txt file

- Visualization modes:
	- Each layer has a visualization mode (TODO: confirm with below)
	- There's always a structural visualization mode, which depends on texture as well
		- Choices:
			- Particle
			- Auto-Texturization (only if no texture layer exists)
	- Then, electrical, when present, has own on top of the others
		- Choices:
			- Particle
			- Circuit (long-term)
	- Ropes, when present, has own on top of the others
		- Lines
	- Texture, when present, has own on top of the others
		- Matte
		- With structural mesh

- Ubuntu:
	- Test User Ships folder

- Misc:
	- When primary layer is other than Texture, render texture layer in texturization mode (as opposed to simple texture-sample mode, i.e. nearest neighbor)
		- This is assuming that ShipTexturizer mocks closely enough tessellation
	- Localization:
		- See if can do separate extraction into separate file, which then is loaded at all times by LocalizationManager together with the other one 
	- Ruler: pick a scale (pixels to meter of original ship), then you choose how long the ruler
		- L shaped: horizontal and vertical
		- Ruler sticks to the canvas
		- Only one ruler at a time
	- Texture Generator for ship canvas:
		- Makes larger image, with bilinear interpolation with alpha blending
			- Ain't that what we've got already for the auto-texturizer?
	- Selectable backgrounds		
	- See if it takes so long to initialize SB::MainFrame that we need IProgress
	- Preferences:
		- New ship size
		- ...all tools' settings...
		- TODO: spec
	- Inherits FullScreen state and shares state changes (so, for example, if exits full screen in ShipBuilder, also Game has exited full screen)
		- How to share state changes? 
			- FullScreenManager class, shared_ptr in both
			- Looked at at each Game<->ShipBuilder switch by receiver
	- Windows installer (or ShipBuilder::MainFrame cctor): on Windows, register shell icon handler for .shp2 files
	- TO-SPEC:
		- What to do with background music when switching back and forth?

- Ephemeral visualization rearch:
	- Current structure:
		- Tool::ctor, Tool::EndEngagement: Take orig clone
		- @ Do:
			
			- DoFillForTempVisualization
				- Layer + Render buffer, ONLY
			- DoFillForTempVisualization
			- DoFillForTempVisualization ...

			- UploadVisualization
			- RefreshView
		- @ Mend, @ End:
			- RestoreStructuralLayerRegionForEphemeralVisualization(orig clone)			

			- UploadVisualization
			- RefreshView
		! Total cost:
			- Tool create: 1 alloc + 1 full copy
			- Tool move: 1 region blit + 1 region fill + 1 full upload
			- Tool end: 1 region blit + 1 full upload
	- Proposed structure 1: token (aka "session")
		- Spec:
			- High-level:
				- The "real" model is never changed during temp visualization
				- The token/session wraps ModelController, providing the latter with own buffers when doing ops on temp viz
					- ModelController operations that happen on both model and temp viz model are implemented generically so they accept external buffers as well
						- Outsourced data:
							- Layer itself
							- Layer viz + its Dirty region == struct LayerVisualization { uq_ptr<RgbaImageData>, opt<Rect> }
			- Tool::ctor, Tool::EndEngagement: 
				- ModelController::InitiateTempVisualization() -> TempVisualizationToken
					- TempVisualizationToken::cctor: take orig clone
					- Tool stores token
			- @ Do:
				- TempVisualizationToken::DoFillForTempVisualization
					- Forwarded to ModelController
				- TempVisualizationToken::DoFillForTempVisualization
				- TempVisualizationToken::DoFillForTempVisualization ...

				- TempVisualiationToken::Render
					- UploadVisualization
					- RefreshView
			- @ Mend:
				- TempVisualizationToken::UndoTempVisualization
					- RestoreStructuralLayerRegionForEphemeralVisualization(orig clone)			

					- UploadVisualization
					- RefreshView
			- @ End (dctor):
				- Same as @Mend
			! Total cost:
				- Tool create: 1 alloc + 1 full copy
				- Tool move: 1 region blit + 1 region fill + 1 full upload
				- Tool end: 1 full upload
		- Details:
			- ModelLayerEphemeralVisualizationSession<TLayer>
				+ Not copyable, yes moveable
				- Members:
					- References to arch members:
						- ModelController &
					- TLayer mOriginalLayerClone
					- LayerVisualization mWorkVisualization
					- Session:
						- DirtyRegion == std::opt<Rect>
				- cctor(ModelController &):
					+ Take original layer clone
					+ Initialize session
						+ DirtyRegion=nullopt
				- Fill(rect, material)
					- 
				- Mend()
					-
				- ~dctor():
					- 
		- TODOs:
			+ Clone rearch

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
DONE
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------

+ Move/merge integral coords/size from shipbuilder to game
	+ Game: "ShipSpace" and "DisplayPhysical/Logical"		
	+ ShipBuilder

+ SB::ViewModel: ortho matrix: see again why ShipSpace says positive bottom
	+ Anchor to the top

+ LayerBuffer.h: "layer buffer" types
	+ StructuralLayerBuffer == Buffer2D<StructuralElement, ShipSpace>
		+ StructuralElement = <StructuralMaterial*>
	+ ElectricalLayerBuffer == Buffer2D<ElectricalElement, ShipSpace>
		+ ElectricalMaterial = <ElectricalMaterial*, instance ID>
	+ RopesLayerBuffer == Buffer2D<RopeElement, ShipSpace>
		+ RopeElement = <StructuralMaterial*, endpoint ID>
	+ TextureLayerBuffer == Buffer2D<rgbaColor, ImageSpace>

+ Use "layer buffers" at ShipFactory
	+ ShipMaterialization class (@GameLib): four buffers
	+ static ShipFactory::MaterializeShip(...) -> ShipMaterialization
		+ See first if can make whole ShipFactory static again
		+ Also includes filling-in Ropes from rope endpoints found in structure (legacy)
			+ Throw on conflicts, like (should be) now
		+ Also includes filling-in Electrical from electrical materials found in structure (legacy)
			+ Throw on conflicts, like (should be) now
	+ ShipFactory::WhateverNow(): use MaterializeShip to get ShipMaterialization and continue from there
		+ Given that you're at it: ShipFactoryTypes::ShipFactoryPoint: nuke vec2i and replace with ShipSpaceCoordinates (and user-facing coords being ImageCoordinates)
	+ Test:
		+ Basic:
			+ Legacy ropes
			+ Native ropes
			X Legacy+Native ropes
			+ Legacy electrical
			+ Native electrical
			X Legacy+Native electrical
			+ Texture
		+ Corner cases:
			+ Ropes: too many endpoints for same Rope ID
				+ All legacy
				+ All native
		+ Both auto-texturization settings
		+ Perf (before & after)
			+ Before: ~100ms (factory including auto-text)
			+ After: ~110ms

+ Check if also old code asserted on Szerszen cargo for hull

+ Ship De/Serialization
	! Spec:
		- Ultimate ship definition consists of LayerBuffers, not images (except for Texture obviously)
		- ShipMaterialization functionality currently in ShipFactory should move to legacy ship deserializer, for formats "png" and "shp"
			- This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
	+ Impl:
		+ ShipMaterialization also carries all attributes of ShipDefinition
		+ ShipDeserializer			
			+ Load(filepath, MaterialDB) -> ShipMaterialization
				+ ShipMaterialization functionality currently in ShipFactory should move to legacy ship deserializer, for formats "png" and "shp"
					+ This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
				+ png
				+ shp
			+ LoadPreview(filepath, MaterialDB) -> ShipPreview
				+ png
				+ shp
			+ Save(ShipMaterialization, filepath)
				+ NOP at the moment
		+ Nuke ShipPreview.cpp
		+ Nuke ShipDefinition.*, ShipDefinitionFile.*
		+ "ShipMaterialization" -> "ShipDefinition"
		+ Use ShipDeSerializer ipv ShipDefinition::Load
			+ ShipDefinition
			+ ShipPreview
		+ ShipFactory:
			+ Nuke MaterializeShip code, just begin with ShipMaterialization (now ShipDefinition) as arg

+ Review whole need of ropes creating structural endpoints @ load type from .shp files
	+ Do at ShipFactory::Create() within the first pass on Ropes (i.e. ExtractRopeSegments => PostProcessRopesLayer())
		+ Fix Szerszen
		+ Fix hull assert
		+ Fix RopesTest for Frontiers crash
	+ And subsequently, check the need for StructuralElement to have RenderColor

+ Model contains the four new layer buffer types (1 as member, 3 as uq_ptr)

+ Merge into shipbuilder

+ Undo
	+ Hierarchy: there are four subtypes of UndoEditAction - for each of the "layer buffer" types - on top of e.g. "resize" and "all layers"
		+ These four are all implemented via a single templated class, templated on TLayerBuffer
			+ Contains TLayerBuffer and origin
		+ Apply() invokes Controller::RestoreLayer(TLayerBuffer const &, origin)
	+ Dirtyness:
		+ Model::DirtyState == {array, metadata, ...}, w/=operator
		+ Base UndoAction has DirtyState member, given via cctor & exposed via getter
		+ Controller::Undo()

+ Auto-zoom on new ModelController
	+ By Controller, at cctor (i.e. after CreateNew() and CreateForShip())
		+ Via ViewModel->CalculateIdealZoom() const -> zoom, then set in ViewModel		

+ Grid view:
	+ Button right of transparency slider
	+ Controller->View
	+ View takes it in cctor
	+ Shader

+ Toolbar rearc:
	+ File panel
	+ Ship settings panel
		+ Resize
		+ Ship metadata
	+ Tool settings panel
	+ Check in-game

+ Replace "Yes/No are you sure" with "Do you want to save your changes before continuing?" -> Yes, No, Cancel
	+ "AskUserIfSure" -> "AskUserIfSave" => returns int (wxID_YES, wxID_NO, wxID_CANCEL)
	+ On yes, call SaveShip(), and if the latter returns false, take the Cancel route

+ ShipLoadDialog: doesn't catch new file
	! It's because at open we don't scan directory unless we've changed directory
	+ Solution:
		+ At open, if haven't changed dir, build map (ordered) of <filepath, last_modif> 
		+ Then compare map with same map built at PreviewReady handling
			+ Requires message to also contain last_modif
		+ If changed: follow same path as if directory changed
		+ Also: make snapshot as above, and then also passes it to thread as replacement of thread's first step
			+ Move ShipPreviewDirectoryManager::EnumerateShipFilePaths to here basically, improving it as we may avoid storing files if not ship files

+ New/Load/Save Ship
	+ Move ShipLoadDialog/etc. under UILib
		+ Test from game:
			+ Last directory is added to both ComboBox and UIPreferences
				+ Yes when loaded
				+ No when not loaded
			+ Show ship descriptions:
				+ Works in dialog
				+ Works at load
				+ User may override
		+ Second home button
	+ New
		+ UI: menu + button
		+ Always enabled
		+ Asks user if model dirty
		+ Invoke DoNewShip()
	+ Load
		+ UI: menu + button
		+ Always enabled
		+ Asks user if model dirty
		+ Open file load dialog
		+ If OK: invoke DoLoadShip(selected filename)
		+ TEST: in Game, 2 dialogs
	+ Save:
		+ UI: menu + button 
		+ Only enabled when dirty
		+ if !mCurrentFilename: invokes SaveAs(); else: invokes private SaveShip(mCurrentFilename)
	+ SaveAs:
		+ UI: menu + button
		+ Only enabled when dirty
		+ Open file save dialog for .shp2
		+ If OK:
			+ Invoke private SaveShip(selected filename)
		
	+ DoNewShip:
		+ Do
	+ DoLoadShip:
		+ Do
		+ Store filename as mCurrentFilename
	+ DoSaveShip:
		+ Ship Preview workflow:
			+ ShipDeSerializer: split out legacy into own class
			+ ShipDeSerializer: LoadShipPreviewData() and LoadShipPreviewImage(ShipPreviewData const &)
			+ ShipPreview ("ShipPreviewData") from .shp2 contains .shp2 filepath itself
			+ ShipDeSerializer::LoadShipPreviewImage: if type is shp2, call ShipDefinitionFormatDeSerializer::LoadPreviewImage(filepath)
				+ else: type can only be png (throw if not) - call legacy LoadPreviewImage() which loads image
				+ Then resize and trim (like it was @ ShipPreview)
			+ .shp2 format: preview is own tag, image chunk saved at ship save time - but only if there's no texture
				+ Order of chunks:
					+ If has texture: metadata, texture, ...
					+ Else: metadata, preview, ...
				+ Do LoadPreview
					+ Have one single main loop for the three load calls
		+ ShipDeSerializer::Save(ShipDefinition const &)
			+ Rearc exceptions:
				+ GameCore/UserGameException
					+ With enum
					+ Exception contains enum and string array
					+ LocalizationManager::MakeErrorMessage(LocalizableGameException const &)
						+ Formats
					+ Catch-&-localize @ callers
						+ Game
						+ ShipBuilder
						+ Preview
				+ Individual methods throw directly LocalizableGameException, no post-processing
					+ DeSerializationContext: private class with file FS version, stored as pair of integers
						+ Nuke MajorMinorVersion class
				+ Unit tests for all exceptions
					+ Header
					+ Unrecognized material in structural layer
				+ Test all w/localized strings
					+ Game
					+ ShipBuilder
			+ Header
			+ Metadata
			+ Ship size section
				+ And no size at buffers
			+ Replace ShipSize with struct ("ShipAttributes" or "ShipFoundamentals") having ship size, hasTexture, hasElectricals, FS version
				+ As a section, made of sub-sections
				+ Section is checked for presence before use, and sub-sections are checked for presence before constructing ShipFoundamentals
				+ Unit tests
			+ Preview
				+ Trim in-place
				+ Make sure image trimming happens only for legacy
			+ Structural layer
				+ RLE with variable-length "u 16-bit" count encoding
					+ DeSerializationBuffer::Read/Write VarUInt16
					+ Orig: 216Kb
					+ Compressed: 30.8Kb
				+ Read
					+ Then complete unit tests
		+ Store filename as mCurrentFilename
		+ Also do load for .shp2
			+ ShipLoadDialog wildcards
			+ ShipDeSerializer::Load():
				+ Header: check (via helper)
				+ Metadata
				+ ...
				+ Verify tail

+ Add some shading around ShipSpace canvas
	+ Four 1-pixel-wide quads drawn with matte color (black)
	+ If we use the same ortho matrix, we need to calc the ship space size of 1 pixel

+ Click-And-Draw use case:
	+ Structural Pencil tool (*)
		+ UndoStack.h/cpp, w/IUndoEntry interface w/UndoEntryType enum
		+ Controller: forward mouse events to tool
		+ View:
			+ Upload method for texture *region*
		+ Application: undo is only baked and added at mouse up, containing whole affected region
			! Spec:
				+ Tool makes clone of entire region at mouse down
				+ At each pixel edit, tool updates region's origin and size
				+ At mouse up, tool makes UndoEntry with clone of material region 
			+ Impl:
				+ Pencil tool is templated on LayerType
				+ Tool has std::opt<InteractionState> with ShipSpaceRect and clone of entire region
					+ LayerTypeTraits<LayerType> gives type of LayerBuffer					
				+ At mouse down: 
					+ Model::CloneStructuralLayerBuffer() -> StructuralLayerBuffer
					X Then capture mouse
				+ At mouse up, tool makes UndoEntry with clipped clone of material region 
					+ Buffer2D has method to be "regionized" (restricted)
						+ Unit tests
					X Then release mouse
					X Then set Model::StructuralLayer as dirty
			+ ModelController::XXXRegionFill does not return UndoEntry anymore
		+ See if OnMouseOut at Tool is really needed
		+ Undo stack:
			+ Owned by Controller, given to Tool
			+ Tool's action writes into UndoStack and invokes IUserInterface notification
			+ IUserInterface notification: Undo menu item
			+ MainFrame: on Undo, call into Controller::Undo()
			+ Controller::Undo:
				+ Calls UndoAction::Apply(this)
				+ Restores dirty state
		+ UndoEntry exposes:
			+ string GetTitle()
			+ std::uint64_t GetCost()
			+ void Apply(Controller &)
				+ Double-dispatch
		+ Controller::RestoreLayerBufferRegion(...) X 4:
			+ Invoke ModelController::StructuralRegionReplace(...)
				+ assert model has layer
				+ Do
				+ Recalc derived
			+ Mark layer as dirty
			+ Notify IUserInterface of dirtyness
		+ Fill-in mouse pointer jumps
			+ Function that takes two integral endpoints and calculates line path, at GameGeometry.h
				+ UnitTests
			+ Use it at PencilTool::CheckEdit:
				+ EnagementData has optional<ShipSpaceCoords> previousEngagement
				+ When we leave CheckEdit because out of bounds, we reset previousEngagement
				+ At application:
					+ Do RegionFill along the path
				+ After we apply the edit, we set previousEngagement
		+ Tool settings: size
			+ Size panel
			+ PencilTool: use size
			+ Rearc layer visualization
				+ Move buffers from Model into ModelController
					+ Add to model controller
					+ Remove from Model
				+ ModelController:
					+ Introduce dirty system for visualization layers: Update() sets dirty region, Upload checks which, uploads, and clears
						+ Single Upload, remove four individual ones
					+ Remove visualization layers upon removal of layers
				+ Controller & Pencil: in a single helper method: 
					+ Ask ModelController to upload visualization (which is based on dirtyness of visualization buffers)
					+ Ask UIInterface to Refresh()
				+ View: terminology: "StructuralLayerVisualizationTexture"
				+ Rethink removal of layers: need to trigger "turning off" of View textures
					! Sequence is: update (@MC), upload (@C)
					+ View::HasStructural/.../Texture() -> bool
					+ MC::Upload: if MC !have && view.has => View::RemoveStructural/.../Texture()
			+ Preview: 
				+ <from Moleskine>
				+ OnCaptureLost: reset tool
					+ Instead of current implementation
				+ Tool cctor: checks IUserInterface::IsMouseInWorkCanvas, based on actual hit test				
				+ OnMouseEnter: Nothing (remove)
				+ OnMouseLeave: forwarded only if not captured (by WorkCanvas)
					+ Tool: Mend temp visualization
				+ FIX: click on scrollbar causes "view change" hence a MouseMove on tool
					+ Controller::SetCamera: only do mouse move if mouse *in* work canvas, and *not* captured by any scrollbar
			+ Anchor
	+ Structural Eraser tool:
		+ Reuse pencil tool, with extra template arg

+ Default ship name (remove TODO)
	+ Use date & time
	+ Helper to make filename (in Utils)
	+ Use it when opening SaveAs

+ Eraser cursor

+ Electrical layer:
	+ Load and Save at DeSerializer
		+ Review MaterialDatabase's electrical material maps: make one map?
			+ Test:
				+ Load png ship with legacy electrical materials
				+ Load .shp ship with instanced and non-instanced materials
	+ Full electrical layer support, like structural
		+ Model
		+ ModelController
		+ Controller
		+ Undo
		+ PencilTool
		+ MainFrame
			+ Hook load->Model
			+ Hook Model->save
			+ LayerPanel
		+ View
			+ Electrical texture parallel
	+ PencilTool: 		
		+ Fix instance index given to fill: strategy for instance ID assignment: fully assigned by ModelController
			+ All primitives invoke internal WriteElectricalParticle(.)
				+ Carefully compare before & after to retain instance ids, create new ones, or reclaim old ones			
					! Strategy to ensure only consecutive IDs, OR only "initial" ones (even if scattered): use ElectricalElementInstanceIndexFactory, member of ModelController
					+ Keep instance IDs in-sync:
						+ ModelController cctor(def):
							+ Visit electrical layer and register existing instance indices w/factory
								+ Do in helper method, which also takes care of Factory::Reset()
									+ "InitializeElectricalLayer()", sets and does the elec analysis initialization below
							! Metadata::ElectricalPanelMetadata is already consistent
						+ New:
							+ Factory::Reset()
						+ Set (Load): 
							+ Visit electrical layer and register existing instance indices w/factory
								+ Do in helper method, which also takes care of Factory::Reset()
						+ Remove:
							+ Factory::Reset()
						+ ElectricalRegionFill						
				+ Also keeps count of electrical particles (for later analysis)
					+ Count initialized - via InitializeElectricalAnalysis() - at cctor,New,Set,Remove
						+ InitializeElectricalAnalysis():
							+ count = 0
							+ if buffer != nullptr: count
					+ Keep count updated
				! Technically, also does running analysis
				! Also takes care of electrical panel: new/removed/updated-type components								
	+ Re-do:
		! Spec:
			! Temp visualization (Fill and Mend) should not update analyses, nor EPM, nor instance IDs
			! Actual committed action (e.g. fill) should update analyses, EPM, and instance IDs
			! Undo: should replace EPM as well, and re-initialize analyses
		+ Impl:
			+ ElectricalLayer contains ElectricalPanelMetadata
				+ "LayerBuffer" -> "Layer" (source file name and type names)
				+ Take map element and map using from GameTypes
				+ Remove EPM from ShipMetadata
				+ LegacyDeser: json is parsed in two phases
				+ De/Ser:
					+ ElectricalLayer has sub-tags (Buffer and ElectricalPanelMetadata)
						+ Unit tests
					+ String tag values?
						+ 'S', 'T', 'C', '1' => S << 24 + T << 16 + C << 8 + '1'
				+ ModelController:
					+ cctor(def): make sure EPM is stored
					+ New: make sure EPM is zerod
					+ Set: make sure new EPM is stored
					+ Remove: make sure EPM is nuked
			+ UndoEntry of electrical must also contain whole ElectricalPanelMetadata
				+ It's Layer + Origin
				+ Should also fly with Structural
			+ Fill and Mend/Replace are split in two:
				+ FillElectricalLayerRegionForTempVisualization and RestoreElectricalLayerRegionForTempVisualization: 
					+ Just populate layer buffer; do not update analyses, nor EPM, nor instance IDs
					+ NOTE: "ForTempVisualization" -> ForEphemeralVisualization
					+ Maintain boolean for asserting at Fill and at RestoreElectricalLayerRegionForTempVisualization
				+ Fill:
					+ Populates layer buffer, and updates analyses, EPM, and instance IDs
						+ Via WriteElectricalParticle(.)
				+ RestoreElectricalLayer: for undo only
					+ Takes also EPM (simply by Layer, arg together with Origin)
					+ Blits layer region
					+ Re-initializes layer (analyses, and instance IDs - EPM already reset)
					+ Replaces EPM in own layer (by move)
					+ Args are by move
				+ Replace(.) goes
	+ Refactor StructuralRegionReplace in the same way (w/WriteStructuralParticle, mending/replace, etc.)
		+ StructuralFill also takes material* instead of element
		+ InitializeLayer & its calls
	+ Tests:
		+ Can load electrical in game, and has panel
		+ PencilTool
			+ Instance ID assignment
		+ PencilTool + Undo
			+ Instance ID assignment
		+ Make sure loading a ship w/legacy electricals makes up an electrical layer, and saving it saves the electricals
	+ Try: do not make line if instanced electrical element
	+ View: other layers' opacity  (NO visualization type! (yet))
		+ View::Set...: stores member
		+ Set param in shader at each use of the shader (i.e. at each layer rendering)
			+ Based on mPrimaryLayer
				+ Do setter and call setter from Controller, prior to visualization update
		+ Controller must refresh (just) rendering (not whole ModelController visualization!)
		+ Primary layer dynamics:
			+ Storage @ Controller				
			+ Controller::cctor sets it in view
			+ Controller::ChangePrimaryLayer: also set in view
		+ OtherLayersOpacity dynamics:
			+ Storage at view
				+ View has it among uploaded
			+ MainFrame: @ view creation: set value on slider, via OtherLayersOpacitySliderToOpacity
			+ MainFrame: @slider change: set value on Controller, via OtherLayersOpacityToSlider
				+ Controller::SetOtherLayersOpacity: sets also in view
			+ See TODOTEST log for opacity values
		+ StructuralLayer: no white BG? Then need BG @ View
			+ Shader: need to take pixel step parameter

+ Flood tool

----------------------

+ Validations:
	! Overview:
		! Validations may either be run by user, or run automatically before saving
		! Errors prevent ship from being saved
		! Some validations also run continuously
	+ Impl:
		+ Object model:
			+ ModelValidationResults:
				+ vector<ModelValidationIssue>
				+ Errors, Warnings, Successes
			+ ModelValidationIssue:
				+ Type
		+ Dialog:
			+ Populate results
				+ ForShipSave: all errors first, then warnings - no success					
				+ ForValidation: as they come
					+ Use sizer->Insert()
				+ Message of issue must be different when success, or title + message
					+ And no Fix button
				+ Handle issues as specific
					+ ElectricSubstratum: button for trimming
						+ Fix OpenGL-on-separate-thread issue
							+ Split Controller::Validate w/SuspendTool/ResumeTool
								+ assert from Validate that it's not in eph viz
								+ Also at MakeDefinition
							+ Suspend/Resume called from main thread in validation dialog
						+ Fix issue with temp viz drawing at ResumeTool()
							+ Should Controller suspend tool automatically at LeftWindow and resume at EnterWindow?
								+ Both only if !captured
							+ Do ToolGuard RIAA - should remember whether it really suspended or not, and resume at destructor only if it did suspend
								+ And at ValidateModel: should now be able to safely simply suspend/resume
								+ And at RestoreLayerRegion
						+ Store undo at Controller::Trim
							+ ModelController::Trim must return region
					- Visualize other issue types
				+ Message before errors and message before warnings - in ForSave mode		
		+ See if can have gauge also @ save
			+ SessionData::IsInValidationWorkflow
				+ Init: false
			+ @timer end:
				+ If IsForSave && all success && !IsInValidationWorkflow:
					+ EndModal(OK)
				+ Else:
					+ IsInValidationWorkflow = true
					+ ShowResults
			+ UI:
				+ cctor: no sizes
				+ ShowModalForStandAloneValidation:
					+ this->SetMinSize(-1, -1)
					+ this->Fit()
				+ ShowModalForShipSave:
					+ Caller doesn't calc nor passes validation
					+ this->SetMinSize(-1, -1)
					+ this->Fit()
				+ ShowResults:
					+ this->SetMinSize(...size...)
					+ this->Fit()
			+ ShowResults:
				+ Not fit
			+ Fix first StartValidation @ ShowModal's: should be called after ShowModal has caused LeaveWindow on WorkCanvas
		+ Dialog open for ship save:
		+ Do validations:
			+ ShipSizeTooBig
			+ Empty structural
			+ TooManyLights
		+ Test
			+ Workflow 1: validation
			+ Workflow 2: save
				+ When there are errors
				+ When there are no errors and there are warnings
				+ When there are no errors and no warnings
