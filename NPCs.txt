NPC Overview
===========

NPCs are of (at least) two types: humans, and furniture. Human NPCs have an AI and move on their own; furniture NPCs are simply static.


NPC Physics
===========

An NPC is represented by one (or more) particles, exactly like all the other particles in FS. The way the NPC particles move depends on the "regime" or "state" in which an NPC finds itself at the moment. There are two possible "regimes".

** Constrained Regime **
This is the initial regime, when the NPC is spawn. In this regime the NPC particle is constrained to move within triangles of the ship, and the particle's movement is the resultant of the NPC's own movement (e.g. walking), friction along "floor" sides of the triangles, counter-gravity generated by "floor" sides of the triangles, and any external forces (including gravity). As an example, when walking on an almost-flat horizontal side of a triangle, gravity has little effect and the NPC moves freely. As soon as the spring becomes too steep, however, gravity wins and the NPC "slides" down the spring.

In the Constrained Regime NPC's normally walk along the springs of the "Paths" layer, i.e. springs of the ship that are also present in the Paths layer. These springs make up the paths that NPC's walk along. However, NPCs may eventually lose their path, for example when at the end of a path or when the path becomes too steep. When this happens, they fall along the ship springs according to gravity, until they reach a path spring again.

An NPC remains in the constrained regime until it reaches a "hole" point, i.e. a point through which normally water would enter. When this happens, the NPC enters the "Free" regime.

** Free Regime **
In this regime NPC's do not follow paths, but rather move freely according to particle physics. They fall when in air or sink, rise, and float when in water. Once in this regime, the NPC stays in this regime.

This regime has a few sub-states controlling the actions and the rendering of the NPC, and a separate algorithm governs the transitions between these states. The states are:
- Floating: the NPC particle is stationary on the sea surface; the NPC might be rendered as asking for help with its arms and moving its legs to stay afloat.
- Sinking: the NPC particle is sinking towards the bottom of the sea; the NPC might be rendered as rotating with limbs moving in arbitrary directions.
- Rising: the NPC particle is underwater but rising towards the sea surface; the NPC might be rendered as swimming upwards.

NPC particles are made of one of few new "NPC" materials, for example "Human NPC", which simulates human mass and buoyancy when breathing, resulting in a particle that would normally *barely* float. If arbitrary transitions between the three states are required - e.g. a floating NPC should start sinking all of a sudden - these will be implemented by means of forces added onto the particles.

NPC Rendering
===========

The particle of a "Human" NPC is considered to be its feet. An additional particle - the head - is attached to the feet via a spring, and only used for rendering purposes. This allows for bending and angular momentum.
This additional particle's mechanical physics is updated at the same loop as the main particle's mechanical physics, but doesn't participate in anything else.
If the concept works fine, we can enhance it later with additional springs for limbs. We will begin with one single particle though.

The two particles define a simple elongated quad. This quad is then rendered with textures, from an atlas containing all NPC frames.
The texture groups' are the "movement types" (e.g. "walking", "falling", "swimming", etc.) (together with furniture NPC types, such as "table", etc.). Each movement type has 1 or more frames, numbered consecutively.

Details
===========

- Type hierarchy:
	- NpcKindType:
		- Human
			- HumanNpcRoleType:
				- Passenger
				- ...
		- Furniture
			- FurnitureNpcType:
				- Table
				- ...

- In the constrained regime:
	- A particle always belongs to a triangle
		- And its world coords can be translated back and forth into barycentric coords wrt the triangle
		- As a special case, the particle may strictly belong to a *side* of that triangle, in which case we assume it's walking on it
			- We can store a "sticking" boolean to remember it's attached, though it's simply a special case of barycentric coords saying it's on a *side*
	- Core of the simulation of an NPC:
		- Starting point:
			- SW: World coords: current coords
			- SR: Relative coords: barycentric coords of SW in old "state of triangles" (which may just be stored at previous frame)
		- Ending point:
			- EW: World coords: SW + integration of:
				- NPC's velocity
				- Floor's friction (only when "sticking" to the floor): f(M * A)
					- M = NPC's mass
					- A = acceleration experienced by triangle
						- Calculated as delta between previous SW and new world position of same barycentric coords
					- f(.) = non-linear switch: force only applied if it's less than a threshold
				- Floor's counter-gravity
					- Only if NPC is on a side of its triangle at beginning of frame
					- In the direction perpendicular to the triangle's side
						- So that we correctly apply it also when NPC is upside-down
				- Forces acting on NPC (gravity, etc.)
		- Algo for physics update of one NPC:
			- 1. F = {g, ext forces}
			- 2. If NPC on spring:
				- Calculate Fa == apparent force due to difference between (current) world position of NPC (SW) and current position of triangle's pos (World(SR))
				- F' = opposite of component of (F+Fa) perpendicular to spring (from inside of triangle)
				- F' += (non-linear) friction due to normal component of (F+Fa) above, tangential to spring
			- 3. Integrate (F + F') and of course NPC's velocity, calculating EW
			- 4. Perform ray tracing; if collision, move NPC and update velocity as usual (i.e. with normal and tangential velocity responses)
		- Details on ray tracing: 
			- Perform ray tracing from SR to EW, in order to:
				- Determine exit & entry through all triangles in path
				- Eventually stop at a floor
			- Details:
				- Start in SR triangle == ST
				- Loop:
					- Calculate relative coords of EW in ST == E'R
					- If E'R is *within* ST:
						- We're done
					- Else:
						- Determine side of ST that SR->E'R path crossed
							- It's gotta be one and only one
						- Check if that side is floor; if it is: apply "collision" logic and stop
						- (if not floor) Find next triangle (triangle opposite that side)
						- If there's no triangle: enter "free regime" and stop
						- ST = this new triangle; continue loop
		- Details:
			- Barycentric coords, and intersection of segment with triangle:
				- https://math.stackexchange.com/questions/2382016/determine-if-a-line-segment-passes-through-a-triangle
			- More barycentric coords, and ray tracing w/C algo:
				- https://web.archive.org/web/20170517125238/http://www.cs.virginia.edu/~gfx/courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
			- Plucker coords, and intersection of segment with triangle:
				- https://members.loria.fr/SLazard/ARC-Visi3D/Pant-project/files/Line_Segment_Triangle.html
				- 2D: https://www.geogebra.org/m/aRMTsu62


Code
===========
Arch:
- One single NPCs container class owned and managed by World
- Render dispatched to individual ShipRenderContext's, as each ship has own Z world
	X Though we could have a NpcRenderContext which passes ship's Z in vertex buffers, but then there's the order/alpha problem; best if rendered by each ship individually

Details:
- NPCs class:
	- Container of NPCs
	- Owned by World; accessed - when needed - by Ships via ParentWorld
	- Contains all NPCs from all ships
		- Organized internally by ship, so that ships may easy access all their NPCs easily e.g. when doing interactions
			- N buffers of buffer<NPC>: <ShipId; -> local ordinal (unstable and not visible from outside)>
				- Innermost buffer kept compact during removals and additions to Ship's specific buffer, hence the reason why the ordinal in that buffer is not stable
		- One single buffer per-physical quantity though, across all ships, so that we do physics updates with one single pass
			- Buffer is pre-sized to max # of NPCs
			- Need same tricks as other physics buffers wrt additions/removals, e.g. zeroing coeffs so that update steps are essentially nop's
		- Identification:
			- Each NPC contains a stable, globally unique single-integer ID, unrelated to the position it occupies in NPC buffers, but
			  equal to the position it occupies in the physics buffer(s)
		- NPC struct:
			- Index: ElementIndex (ordinal in physics buffer)
			- Type: NpcKindType
			- Union of all kind-specific attributes
				- Note: many attributes will be common, hence we're saving room
	- World::AddHumanNPC(..) -> ID
		- World finds ship by inverse Z order, using Ship.GetTriangles().GetTriangleContaining(.)
			- If not found, pick last by default
		- Then World calls NPCs::AddHumanNPC(.., ship const &, triangle index)
	- Update()
	- Upload(iShip, ShipRenderContext)
		- Invoked by World for each ship separately
		- Invokes ShipRenderContext::UploadNPC:
			- A TextureGroup enum - declared in RenderTypes like AntiMatterBomb is for example - is used to identify the "movement types" for rendering. An additional index provides the sub-frame. The whole coordinate is a TextureFrameId<NPC group>.
				- TODO: actually the enum might not have to be in RenderTypes; we could use a generic "state" enum in GameTypes which *also* serves as a groups enum
- Placing an NPC:
	- The user selects the "place NPC" tool at the same time as choosing the type and sub-type via menus
	- Once the tool is selected, ToolController is notified via a dedicated API (which takes type/subtype)
		- With this call the tool is switched to the NPC-placing tool, but the old one is remembered so that once an NPC is placed, we can go back to the previous tool (unless SHIFT is pressed)
	- Initialization of the tool makes a call into NPCs::AddHumanNPC(..) stating its state is "being placed" and gets the ID
		- At this moment GameController starts skipping updated of everything but NPCs - calling a special UpdateXXX() function to only update the rendering state of being-placed NPCs
	- When placed, tool calls NPCs::ResetNPC(ID) which starts the NPC's state machine
		- And GameController returns to normal










- OLD:
- "Walkability"
	- A particle is either "walkable" or not
	- A spring is "walkable" only if both endpoints are "walkable"
		- "Walkabaility" of springs is maintained at destroy and repair
	- A specific "Paths" (or "FloorPlan") layer provides a bitmask indicating which particles are walkable and which are not
		- When the layer is absent, the bitmask is created automatically with the hullness of particles

- Walking:
	- A given walkable spring has effectively two sides, and thus we need to remember on which side we are
		- Example: we're walking on a spring, and then ship is rotated by 180 degrees: we need now to fall, rather than continue walking on the other side of the spring
	- An NPC then remembers:
		- Which spring it's walking on, and
		- Which of the two endpoints is at its *right* when the NPC is staring at us

- State machine(s):
	- Constrained regime:
		- Freefall state:
			! In this state an NPC is falling down a non-walkable spring
			- Do hole check to check for transition to Free regime
			- When mid-spring: slide along spring in the direction that is most aligned with gravity
			- When the NPC reaches an endpoint of the spring:
				- If the point is non-walkable:
					- Choose the next spring (by definition: non-walkable): 
						- The one most aligned with gravity
					- Keep falling (stay in this state)
				- Else (the point is walkable):
					- Transition to Landed state
		- Landed state:
			! Temporary state, exists for animation
			- Do hole check to check for transition to Free regime
			- TODOHERE: incorporate "remembering *right* endpoint of spring we're walking on" from here on
			- From here, after some time: choose a walking direction: "left" or "right", then transition to Walking_MakeNextChoice
				- TODO: see below if we actually can find next spring without having an incoming spring
		- Walking:
			! When an NPC is walking, it follows a predefined direction, either "left" or "right"
			- Do hole check to check for transition to Free regime
			- When mid-spring:
				- Calculate velocity:
					- TODO: resultant of constant WalkingVelocity in the direction of the walk with gravity (projected along spring) + friction
					- TODO: incorporate "remembering *right* endpoint of spring we're walking on" from here on
				- Move by velocity
			- When the NPC reaches an endpoint of the walkable spring: transition to Walking_MakeNextChoice state
		- Walking_MakeNextChoice:
			- Do hole check to check for transition to Free regime
			- Choose the next spring:
				! Could be the same as the incoming in case we're sliding
				- The first non-deleted walkable spring (first in CW direction if going R, else CCW if going L, from the incoming spring)
					- TODO: see if can do without having to remember incoming spring: redefine how we choose next spring knowing only the wanted direction
				- If it is in the walking direction, and if it is not too steep
					- Steepness check uses friction of walkabaility
			- If a choice can't be made: invert direction
				- Stay in this state so we still need to make a choice

	- Free regime:
		-
