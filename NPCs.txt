NPC Overview
===========

NPCs are of (at least) two types: humans, and furniture. Human NPCs have an AI and move on their own; furniture NPCs are simply static.


NPC Physics
===========

An NPC is represented by one (or more) particles, exactly like all the other particles in FS. The way the NPC particles move depends on the "regime" or "state" in which an NPC finds itself at the moment. There are two possible "regimes".

** Constrained Regime **
This is the initial regime, when the NPC is spawn. In this regime the NPC particle is constrained to move within triangles of the ship, and the particle's movement is the resultant of the NPC's own movement (e.g. walking), friction along "floor" sides of the triangles, counter-gravity generated by "floor" sides of the triangles, and any external forces (including gravity). As an example, when walking on an almost-flat horizontal side of a triangle, gravity has little effect and the NPC moves freely. As soon as the spring becomes too steep, however, gravity wins and the NPC "slides" down the spring.

In the Constrained Regime NPC's normally walk along the springs of the "Paths" layer, i.e. springs of the ship that are also present in the Paths layer. These springs make up the paths that NPC's walk along. However, NPCs may eventually lose their path, for example when at the end of a path or when the path becomes too steep. When this happens, they fall along the ship springs according to gravity, until they reach a path spring again.

An NPC remains in the constrained regime until it reaches a "hole" point, i.e. a point through which normally water would enter. When this happens, the NPC enters the "Free" regime.

** Free Regime **
In this regime NPC's do not follow paths, but rather move freely according to particle physics. They fall when in air or sink, rise, and float when in water. Once in this regime, the NPC stays in this regime.

This regime has a few sub-states controlling the actions and the rendering of the NPC, and a separate algorithm governs the transitions between these states. The states are:
- Floating: the NPC particle is stationary on the sea surface; the NPC might be rendered as asking for help with its arms and moving its legs to stay afloat.
- Sinking: the NPC particle is sinking towards the bottom of the sea; the NPC might be rendered as rotating with limbs moving in arbitrary directions.
- Rising: the NPC particle is underwater but rising towards the sea surface; the NPC might be rendered as swimming upwards.

NPC particles are made of one of few new "NPC" materials, for example "Human NPC", which simulates human mass and buoyancy when breathing, resulting in a particle that would normally *barely* float. If arbitrary transitions between the three states are required - e.g. a floating NPC should start sinking all of a sudden - these will be implemented by means of forces added onto the particles.

NPC Rendering
===========

The particle of a "Human" NPC is considered to be its feet. An additional particle - the head - is attached to the feet via a spring, and only used for rendering purposes. This allows for bending and angular momentum.
This additional particle's mechanical physics is updated at the same loop as the main particle's mechanical physics, but doesn't participate in anything else.
If the concept works fine, we can enhance it later with additional springs for limbs. We will begin with one single particle though.

The two particles define a simple elongated quad. This quad is then rendered with textures, from an atlas containing all NPC frames.
The texture groups' are the "movement types" (e.g. "walking", "falling", "swimming", etc.) (together with furniture NPC types, such as "table", etc.). Each movement type has 1 or more frames, numbered consecutively.

Color coding:
- TODO: https://www.reddit.com/r/gamedev/comments/3215xb/replacing_texture_colors_in_opengl/
- texture3d: 
	- Basics: https://stackoverflow.com/questions/20012676/glsl-change-specific-color-of-texture-to-another-color and https://www.reddit.com/r/opengl/comments/1x2rq1/how_can_i_replace_one_color_from_a_texture/
	- To create LUT table: http://kpulv.com/359/Dev_Log__Color_Grading_Shader/

Frame rules:
1. Frame size is 64x64
	Max 4096 frames
2. Try to maximize canvas usage. Ideally, for the "standing" frame, the feet touch the bottom edge, and the topmost pixel (above the head) touches to top edge
3. Each frame will have to be duplicated for man and woman appearances
4. We're going to use color coding. Basically, some of the colors in each frame will be changed at rendering time to allow for differently-colored uniforms for different roles.
	So for example we can have role-specific colors for the pants/skirts, jackets/shirts, and if we want, stripes on the arms and/or legs, and hats
	Like at https://www.reddit.com/r/gamedev/comments/3215xb/replacing_texture_colors_in_opengl/
4a. Background has to be full white (255, 255, 255)
	If we need actual white in the frame, we can use a slightly darker white
4b. (and this part I still have to think through completely, but we can start with this)
	You may use any colors you want, but these are special and will be replaced by role-specific colors
	medium red: 128, 0, 0: upper body (shirt/jacket)
	light red: 255, 0, 0: lower body (pants/shirt)
	medium green: 0, 128, 0: shoes
	light green: 0, 255, 0: hat
	medium blue: 0, 0, 128: unassigned at this moment (don't use)
	light blue: 0, 0, 255: unassigned at this moment (don't use)
5. Walking frames: 
5a. 3 frames (1: left leg ahead, 2: both legs vertical, 3: right leg ahead)
5b. The upper body vertical axis needs to be horizontally centered and needs to stay aligned vertically - basically, the animation needs to look fluid if you alternate the three frames always at the same position

Details
===========

Arch
===========

- Type hierarchy:
	- NpcType:
		- Human
			- HumanNpcRoleType:
				- Passenger
				- ...
		- Furniture
			- FurnitureNpcType:
				- Table
				- ...

- One single NPCs container class owned and managed by World
- Render dispatched to individual ShipRenderContext's, as each ship has own Z world
	X Though we could have a NpcRenderContext which passes ship's Z in vertex buffers, but then there's the order/alpha problem; best if rendered by each ship individually

- NPCs class:
	- Container of NPCs
	- Owned by World; accessed - when needed - by Ships via ParentWorld
	- Contains all NPCs from all ships
		- Organized internally by ship, so that updates - which require ship triangles, etc. - are optimized, and ships may easy access all their NPCs easily e.g. when doing interactions
			- For each ship there is a vector (e.g. std::vector<NPCState>), kept compact during removals and additions of NPCs
			- The vector of ships is also itself kept compact during removals and additions of ships
			- Separately, a "ship index" vector and a "NPC index" vector for each ship form a two-tier "index" for mapping stable ShipIDs and NPCIDs to elements in these buffers
				- Index also kept up-to-date at Ship and NPC addition/removal
				- The pair of these indices is the NPC's stable, globally-unique ID, unrelated to the position it occupies in NPC buffers
		- One single buffer per-physical quantity though, across all ships and NPCs, so that we do physics updates with one single pass
			- Buffer is pre-sized to max # of NPCs
			- Need same tricks as other physics buffers wrt additions/removals, e.g. zeroing coeffs so that update steps are essentially nop's
		- NPC struct:
			- Type: NpcKindType
			- Union of all kind-specific attributes
				- Note: many attributes will be common, hence we'll be saving room
			- type: NpcParticleState
				- ElementIndex ParticleIndex (index in NpcParticles)
				- opt<ConstrainedStateType> ConstrainedState
					- TriangleElementIndex
					- BaryCoords
					- opt<OnFloorStateType> OnFloorState
						- EdgeOrdinal
						- SimulationTime startTime - TODO: dynamics of when reset
			- NpcParticleStateType PrimaryParticleState (i.e. feet)
			- opt<NpcParticleStateType> SecondaryParticleState (i.e. head)
	- Update(Ship const &)
	- Upload(Ship const &, ShipRenderContext)
		- Invoked by World for each ship separately
		- Invokes ShipRenderContext::UploadNPC:
			- A TextureGroup enum - declared in RenderTypes like AntiMatterBomb is for example - is used to identify the "movement types" for rendering. An additional index provides the sub-frame. The whole coordinate is a TextureFrameId<NPC group>.
				- TODO: actually the enum might not have to be in RenderTypes; we could use a generic "state" enum in GameTypes which *also* serves as a groups enum

- In the constrained regime:
	- A particle always belongs to a triangle
		- And its world coords can be translated back and forth into barycentric coords wrt the triangle
		- As a special case, the particle may strictly belong to a *side* of that triangle, in which case we assume it's walking on it
			- We can store a "sticking" boolean to remember it's attached, though it's simply a special case of barycentric coords saying it's on a *side*
	- Core of the simulation of an NPC:
		- Starting point:
			- SW: World coords: current coords
			- SR: Relative coords: barycentric coords of SW in old "state of triangles" (which may just be stored at previous frame)
		- Ending point:
			- EW: World coords: SW + integration of:
				- NPC's velocity
				- Floor's friction (only when "sticking" to the floor): f(M * A)
					- M = NPC's mass
					- A = acceleration experienced by triangle
						- Calculated as delta between previous SW and new world position of same barycentric coords
					- f(.) = non-linear switch: force only applied if it's less than a threshold
				- Floor's counter-gravity
					- Only if NPC is on a side of its triangle at beginning of frame
					- In the direction perpendicular to the triangle's side
						- So that we correctly apply it also when NPC is upside-down
				- Forces acting on NPC (gravity, etc.)
		- Algo for physics update of one NPC:
			- Done at BaryLab
				- 0. If current triangle (guaranteed to be set) has been deleted, transition to free regime
					- Note: triangle deleted <=> spring deleted, so this is regardless of whether NPC is on spring or not
				- 1. F = {g & world forces, ext forces}
				- 2. Note: the below is apparently not needed if we take care of impact response when on edge (below); verify that we can take care of friction well in the edge code,
				     when we have no idea of relative movements
				     - If NPC on spring:
					- And: allow when in floor to move like ghost, so if NPC on spring _and_ not all springs of triangle are floor
					- Calculate Fa == apparent force due to difference between (current) world position of NPC (SW) and current position of triangle's pos (World(SR))
					- F' = opposite of component of (F+Fa) perpendicular to spring (from inside of triangle)
						- Note: only if normal is right direction wrt trajectory
					- F' += (non-linear) friction due to normal component of (F+Fa) above, tangential to spring
						- Static and kynetic friction:
							- http://www.epi-eng.com/mechanical_engineering_basics/force_and_friction.htm
							- https://www.motioncontroltips.com/why-is-static-friction-greater-than-kinetic-friction/#:~:text=Static%20friction%20is%20what%20keeps,once%20they%27re%20in%20motion.
							- https://openstax.org/books/university-physics-volume-1/pages/6-2-friction
								- The direction of friction is always opposite that of motion, parallel to the surface between objects, and perpendicular to the normal force.
				- 3. Integrate (F + F') and of course NPC's velocity, calculating EW
				- 3b. Reset ext forces
				- 4. Perform ray tracing; if collision, move NPC and update velocity (bounce) as usual (i.e. with normal and tangential velocity responses)
					- Impact forces: https://www.studysmarter.co.uk/explanations/physics/force/impact-forces/
				- Details on ray tracing: 
					- Perform ray tracing from SR to EW, in order to:
						- Determine exit & entry through all triangles in path
						- Eventually stop at a floor
					- Details:
						- Start in SR triangle == ST
						- Loop:
							- Calculate relative coords of EW in ST == E'R
							- If E'R is *within* ST:
								- We're done
							- Else:
								- Determine side of ST that SR->E'R path crossed
									- It's gotta be one and only one
								- Check if that side is floor; if it is: apply "collision" logic and stop
								- (if not floor) Find next triangle (triangle opposite that side)
								- If there's no triangle: enter "free regime" and stop
								- ST = this new triangle; continue loop
		- Details:
			- Barycentric coords, and intersection of segment with triangle:
				- https://math.stackexchange.com/questions/2382016/determine-if-a-line-segment-passes-through-a-triangle
			- Cartesian to Barycentric: https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates
			- More barycentric coords, and ray tracing w/C algo:
				- https://web.archive.org/web/20170517125238/http://www.cs.virginia.edu/~gfx/courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
			- Plucker coords, and intersection of segment with triangle:
				- https://members.loria.fr/SLazard/ARC-Visi3D/Pant-project/files/Line_Segment_Triangle.html
				- 2D: https://www.geogebra.org/m/aRMTsu62

= Human behavioral state machine(s):
	! Principles:
		! Most transitions happen with "convergence" of some quantity
			! Only the convergence rate is a state-specific parameter; the threshold for reaching a target is not (i.e. it's a global constant)
				! So that there's only one param per state controlling timing
	+ States:
		+ State:KnockedOut
			! Does nothing
			+ Transitions out: 
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following applies for at least Tx: transition to Rising
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
					+ S particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
		+ State:Rising
			! Tries to stand up (applying torque)
			+ Transitions out:
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following stops applying: transition to KnockedOut
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
				+ When MaintainAndCheckEquilibrium() returns false: transition to KnockedOut				
				+ When line from S to P is aligned with GravityDir: transition to Equilibrium
			+ External out transitions:
				+ Impact: transition to KnockedOut
					+ UpdateStep() takes NpcState as well, and calls Npcs::OnHumanNpcImpact(NpcState, impact quantities) upon impact
						+ OnHumanNpcImpact: switches on state
		+ MaintainAndCheckEquilibrium() -> bool:
			+ Does torque calculation and reaches/maintains equilibrium, but also checks if conditions to stay in equlibrium  apply; stops equlibrium (and returns false) if:
				+ HumanVector is outside of -alpha->alpha sector around vertical, with rotation velocity towards outside of sector
		+ Impart torque:
			+ With Particles::VoluntaryForces
				= Reset at state transitions
			+ Formula:
				+ Force perpendicular to human vector; magnitude depends on angle
				+ See why primary moves: is it because of spring being compressed?
					+ It's because at beginning each step stretches it, then the spring recoils to the point that the other endpoint needs to move
				+ Force can't be directional - or else it cancels gravity - not that it's important, but highlights un-soundness of approach
					+ Go full rotational spring
				+ See if can raise faster with less overshooting
		+ State:Equilibrium
			! Stands up; continues to adjust alignment with torque
			+ Transitions out:
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following stops applying: transition to KnockedOut
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
				+ When MaintainAndCheckEquilibrium() returns false: transition to KnockedOut
				+ When enough time has passed in this state: transition to Walking
			+ External out transitions:
				+ Impact: transition to KnockedOut
		+ State:Walking
			! Walks; continues to adjust alignment with torque
			+ Transitions out:				
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following stops applying: transition to KnockedOut
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity (excld. walking)
				+ When MaintainAndCheckEquilibrium() returns false: transition to KnockedOut
			X External out transitions:
				X Impact: transition to KnockedOut
			+ Walking state machine:
				+ Impart displacement
					+ First, allow traj calculation to also pre-calculate final (absolute) velocity
						+ Traj calc state keeps it, "TargetAbsoluteVelocity"
						+ UpdateTrajState() returns it when completing w/out impact
							+ finalParticleState has velocity not as optional but as mandatory
								+ No more automatic vel calc'n at end of UpdateTrajState()
							+ Always provide target vel from within UpdateTrajState()
								+ Assert it matches a calculated one - when no impact has happened						
					+ Then: at traj calculation, superimpose raw walking displacement (calcd at HumanUpdate and stored in VoluntarySuperimposedDisplacement) to traj, without affecting velocity
					+ FIX: secondary trails primary
						+ @ TrajCalculation: when we incorporate walking displacement, if it's primary we save same vector as displacement of secondary
						+ At HumanNpcStateUpdate: clear also secondary displacement on transitions out
				

		+ Problem: while walking, difference in slope is giving us troubles:
			+ When moving from edge floor to edge floor with lower slope, we lose contact with edge
				+ And this happens because once we climb to other triangle, the trajectory end in bary coords does not lie anymore on edge
			+ When moving from edge floor to edge floor with higher slope, primary has impact and gains bounce velocity (because we check traj)
			+ Solution: might need to change how impact works, if walking reaching slope that it should try to climb causes noticeable impact
				+ We can solve it @ impact detection by checking slope first, and not causing impact bounce when slope is gentle - but still climbing over edge in order to "land" on slope
				+ Do rearc 

		+ RETHINK: do we really want primary non-inertial to gain physical velocity when walking? Example: climbing up, gains however down velocity until this one overpasses walking
				- May be it's OK after all...
			! Also: BUG: impact of secondary when discounting walk vector results in anti-impact
			X Algo 1 for fix:
				! If result is opposite sign of phys, shouldn't gain phys but zero instead
					! If result is opposite sign of zero, should gain zero (this is now)
					! In other words: velocity gain should never be opposite of result (actual)
				! Generalization: velocity gain max should be:
					! Result > 0: max(phys, 0) // e.g. climbing up on \* : only gains > 0
					! Result < 0: min(phys, 0) // e.g. climbing up on */ : only gains < 0
				X Do:
					X Do new velocity calculation at 3 places (TODOHEREx):
						= 1: NonConstrained move-to-place: here we do with edgeDir
						= 2: Constrained move-to-place: here we do with absolute positions; velocity is:
							- Direction: of result (i.e. result_dir)
							- Magnitude: as above, with phys projected onto result_dir
							- TODOHERE: conflicts with torque!
						- 3: Bounce when calculating incident velocity - incident velocity must be same as in 1 and/or 2
					- Double-check passed walked total/planned vs primary/secondary
						- Primary: totalEdgeWalkedActual starts from zero and grows step-by-step
						- Secondary: totalEdgeWalkedActual is resultant from primary since the beginning, and immutable
			+ Algo 2 for fix:
				! Add walk *displacement* calculated to *fill-in* (desired) walk vector
					! If (planned) physics is already more, then displacement is zero
					! The displacement then takes part in normal velocity calculations
					! This displacement is the one which, summed up, goes to secondary
				+ Plan:
					+ Undo other changes (surgically)
					+ Main loop:
						+ Primary: new plannedWalk calculation
							+ if walk in same direction as edgeDir:
								- plannedWalkVector = edgeDir * max(walk desired along edge - planned phys along edge, 0)
								OR - so that we don't walk on too steep:
								- plannedWalkVector = edgeDir * min(max(walk desired along edge - planned phys along edge, 0), walk desired along edge)
							+ else:
								- ...
							+ actualWalk is then added to total (as now)
							+ plannedWalk is added to plannedPhys to make plannedTotal (as now)
						+ Secondary:
							+ actualWalk taken from primary (as now)
					+ All three velocity calculations:
						+ Back to basics: just take whole, real displacement - hear nothing of "walked"
							+ Remove "walked" and "phys/total" args
								+ Unless phys/total is used for assert - keep "total" for that
					+ Problem fix
						+ Disable storing equilibrium torque
						+ Disable secondary displacement
						X At phys force calc: if NPC is walking and this is secondary, calc additional force - on top of calcd - needed to bring sec'ry on top of primary
							X Do in "distance" space
						+ Do normal torque here
				+ Things to fix:
					+ Bump with vertical wall: going back (when floor is sloped down-right) is not constrained anymore because of |\*| <--
						! Which means we do another bump (albeit negligible but still against direction, dot is 0.06) and thus another flip
						+ Option 1: at main loop: if we are at a cuspid, we shouldn't be too hasty in deciding non-inertial vs inertial; should move out of cuspid first
							+ Almost same loop as in NonInertial: until in triangle or becomes free or hits floor
					+ Walks on too steep of a wall
						+ Happens because friction zeroes out G
						X This should be fixed with less friction
						+ Two-sided fix:
							+ Clip and squash dot product at actual walk plan calculation ("apply G resistance")
							+ MaintainWalk: flip if too long at V opposite of W
								+ 1: Check condition (V opposite of W); if true: TargetFlipDecision=1.0; else: Target&CurrentFlipDecision=0.0
								+ 2: Advance CurrentFlipDecision towards TargetFlipDecision
								+ 3: If CurrentFlipDecision > 0.95: flip, & set Target&CurrentFlipDecision=0.0
								+ Replaces having to flip at well detection? Verify it can, both sides
									+ Turn off first for test
									+ Verify it replaces it
								+ Set FlipDecisions to zero at bounce flip
								+ HumanFlip(isImmediate)
									+ Called by both places at which we flip
								+ Later: test with a margin above @ 1 so that we also flip when yes V in same direction as W but not quite there
									+ FIX: looping around 0.0/~-0.0
					+ See if can lose equilibrium when secondary too skewed but not too much relative opposite vel because of secondary being blocked
						+ In equilibrium only, CheckEq breaks Eq at lower threshold - even when relative V is same sign but quite low
					+ Slow when walking downhill: because of "gravity resistance", which shouldn't apply when downhill (only uphill)
						+ Do better curve w/Smoothstep
						+ "GravityAllowance"
				+ Higher static and kinetic friction
					X Google V for change from S to K
				+ Lower walking speed
				+ Fix torque w/mesh velocity
					+ Is it that at torque calc we see primary already moved - by a lot - while secondary hasn't moved yet?
				+ Video
					+ Code for script
					+ Fix little jump
						+ Add tolerance
						+ Don't invoke walk update when not on edge - w/comment on not needing to silence walk mag as we don't apply walking when inertial (i.e. when not on edge)
						+ Test flying off
				+ "Jump tolerance" also for other two states
					+ 1. Thus regardless of state
						+ HumanState.CurrentEquilibriumSoftTerminationDecision
							+ Reset also at transitions to Rising & Equilibrium
						+ Do not start walking if not on edge
					+ Test w/walk & ball
					+ Commit before next one
					+ 2. Do not apply torque while not on edge
						+ Go back to having NpcParticle float buffer (w/1.0 or 0.0) for torque
						+ reset() buffer before NPC loop
							+ w/note for prelim forces
						+ Set it from CheckAndMaintainEq(...isOnEdge...)
							+ Simply iff on edge
						X Make sure we zero it when leaving any of the states
						+ Use at torque calculation
				+ Flip also when *secondary* bounces
				+ Sea level:
					+ Param, UI
					+ World forces: if free
						+ Find sweet spot for thickness of interface/buoying at shoulders
							+ Offset for sea level to account for head
						+ Forces rearc:
							+ NpcParticle has PreliminaryForces
								+ All those we can calc @ beginning
							+ Npcs::CalculatePreliminaryForces()
								+ Takes care or cleaning - if needed
							+ Npcs::CalculateDefinitiveForces()
					+ Material buoyancy
					+ Rendering
				+ Cleanups if ok:
					+ CalculatePhysForces
					+ Old torque 
						+ And "voluntary" buffer for torque force?
					+ Do we still need "voluntary" displacement of secondary?
					+ Make triangle-finding (rotate through vertices/cuspids) a function ("NavigateVertex")
						+ Return: <do_stop> (note: no need to return traveled - it never moves)
						+ Issues found along the way:
							! With this func we bounce when we normally didn't
								! e.g. in main loop: old: when detecting floor while navigating, we'd stop, and then yada yada (flatten -> move to target as it's in triangle);
								  new: we bounce instead
							+ Fix: return indication of bounce but not bounce
								+ FloorEncounteredOutcome/intervening
								+ ~became free
								+ ~completed navigation
						+ Integrate with NonConstrained loop
						+ Test
						+ Cleanup old code
					+ "TODO: get rid of this" (local triangle index)
					+ @BlabTypes: baryCoords // copy vec3f parts we need
						+ TryGetVertexOrdinal() -> opt<int>
				+ When finding triangles (e.g. opposite triangle, but also initializations), check if triangle is deleted
				+ Test:
					+ Flying off
						+ Primary into inertial
						+ Secondary into inertial
						+ Primary into free
						+ Secondary into free
					+ Starting at vertex
					+ With mesh moving

		+ Video

		+ Animation:
			+ Store current edge
				! Needed for foot points
				+ ConstrainedState::CurrentVirtualEdge // not really valid when at cuspids
				+ Set after call to NonInertial
				+ Render it (dark red)
				X FIX: when trying to walk up, virt edge is the vertical one
					! see below, at walking points-along-edge - see how it goes - WELL
			+ Move behavior update: update behavior before animation, after physics
				+ FIX: it's broken
					+ Because we lose EquilibriumTorque, move reset afterwards
				+ Test
			+ Shader
				+ Basic
				+ Do ellipses
			+ Store total travelled (displaced)
				+ New HumanState member: float TotalEdgeTraveledWhileWalking
				+ Reset it when entering Walking state
				+ Also in inertial mode, as we now might be walking
					+ Do it now and see if it looks weird
			+ Decide where to put human body proportion constants
				+ LabParameters
			+ Move points (new Human members) @ Update
				! Each state is responsible for it
				+ Walking:
					+ 1. Formula calculating angle, as rotation of legs
						+ Angle members, and points as well (points will be useful for more calc's later, see below)
							! We want angles so that we can smooth-merge sequences
							+ CurrentLegRightAngle, no need for Target
							+ AnimationUpdate calc's targets and smooths currents to it
						+ Formula:
							+ A: atan-based along horiz (horiz because human is vertical)
						+ Calc points: trivial
						+ Adjust step size
					+ 2. Constrain points to be along current edge's direction
						+ Direction dictated by angle, it's only *length* of leg that changes to stop at current edge
						+ Option 1: https://math.stackexchange.com/questions/406864/intersection-of-two-lines-in-vector-form
						- Option 2: by calculating from a "virtual crotch" perpendicular to edge
					+ 3. Limit leg angles based on slope
					+ Smooth out transition between current virtual edge presence & slope:
						+ First off: if and when smoothing points, we don't smooth absolute positions (as limbs would elongate/shrink with fast moves) but rather angle & length, 
						  or position relative to shoulder/crotch
							! Same is for angles, but that comes by itself: angle gives position only after taking current absolute positions into account
						+ New plan:
							+ Each switch case calcs target angle and target length
							+ Function then smooths those and calcs vectors - relative to shoulder (F/B), crotch (F/B)
						+ Finish target leg length calculation
						+ Lengths:
							+ head, neck, shoulder, crotch, feet: based on current dipole length
							+ arms, legs: based on ideal * adjustment
					+ Make human walk up slope faster
						+ Change formula
			+ Add arms
				+ Redo whole body, make proportion constants at top of file
			+ Fix "running away" issue:
				! Repro: start at vec2f const position = vec2f(-0.634f, -2.0f);
				! At second iteration of main loop, dt is very small but trajectory is still original:
				+ 0: Build repro with ball & velocity first

				+ Attempt 1: budget-based:
					+ 1: first flattening stores "budget" == length (abs) of flattened traj
						! "budget" is the maximum *total* distance that we are allowed to travel in current time quantum
					+ 2: "budget" is reduced after each iteration by (abs) scalar amount traveled (capped to zero - though shouldn't be needed)
					+ 3a: any subsequent non-inertial flattening adjusts flattened trajectory to ensure its abs length is not over budget
						X Adjust how we calc dt consumed - no need as long as we update edge total planned
						X Adjust physical planned - no need as it's not used anymore
						+ Adjust walk planned, which is used 
					X 3b: any subsequent inertial travel adjusts trajectory to ensure its abs length is not over budget
						! Not needed: velocity here is calc'd from total trajectory in step divided by theoretical (whole) dt, so it's really physical
					+ Then:
						X a: Fn calculation (for friction) must take dt into account
							! Actually, is not needed - N and FT would both be smaller - as smaller as T is
						X b: Also bounce response must take dt into account?
							! Actually, is not needed - bounce response is calc'd based on (flattened) trajectory and (remaining) dt
						+ c: Impact continuation must also calc velocity as it might be last
							! Next step might have 0 to travel after we shorten up traj
							+ Test assert on non-inertial always leaving a crumble of distance to travel wrt budget
								+ Seems to hold

				+ Finalize, Cleanup, Merge

			+ Fix "neverending navigation" issue:
				+ Build repro 
				~ Do dual-side (0.0 and 1.0) clamping for each coord

Opposite Tr 46 oppositeTriangleCrossedEdgeOrdinal=0 newBCoords={_Elems=0x00000017b298da68 {1.00000000, 0.00000000, 0.00000000} }
vertexOrdinal=0 TrajEndBCoords={_Elems=0x00000017b298ddd0 {0.998306274, 0.00169372594, -3.49245965e-10} }
preV=2 nexV=1 => crossedEdgeOrdinal=0

Opposite Tr=81, oppositeTriangleCrossedEdgeOrdinal=1 newBCoords={_Elems=0x00000017b298da68 {0.00000000, 0.00000000, 1.00000000} }
vertexOrdinal=2 TrajEndBCoords={_Elems=0x00000017b298ddd0 {-1.61526414e-09, 0.00169372361, 0.998306274} }
prevV=1 nextV=2 => crossedEdgeOrdinal=1

Opposite Tr 46 oppositeTriangleCrossedEdgeOrdinal=0 newBCoords={_Elems=0x00000017b298da68 {1.00000000, 0.00000000, 0.00000000} }
vertexOrdinal=0 TrajEndBCoords={_Elems=0x00000017b298ddd0 {0.998306274, 0.00169372594, -3.49245965e-10} }

81:
|\
| \
|  \
----
\  |
 \ |
  \| 46
				+ Now that we clamp, we have the issue of bouncing once reached the edge - because of walk velocity going up
					! Repro: vel=1.8, slightly rotated CCW
					X Attempt 1: do not gain y velocity from walk
						! But does it make sense? If we run up, we have velocity up...no?
						X Attempt 2: limit y velocity from walk
					+ Attempt 3: better bounce tolerance and equilibrium termination
						+ Bounce tolerance to slope vs walking dir
							! Repro: max speed & mesh rotated CW (1xV)
						+ Equilibrium termination: provided we're reasonably vertical, if we lose it because of non-edge, be more tolerant
						+ But now we have relative velocity kicking in
							! Rethink relative velocity - after all we have walking velocity now!
							+ If not walking: like now
							+ Else:
								X If against walk dir by limit1: break
									! We do not need this - after all we flip - and also generates issue below (slamming against wall)
								+ If more than walk velocity by limit2: break
								+ Only consider component of MRV along walk dir
							+ FIX: when we slam hard against a wall, we flip but still have old V => it looks like a lot of opposite
								+ Attempt 1: see above: removing "Walking state abandonment" when too much opposite vel fixed this

				+ Sfarfallio when we reach slope 
					! Repro: speed=1.75, rotated cw a bit (6 x -3.1f * 12.0f)
					! We do impact continuation & try go up slope, but too much friction/nowalk/etc. and no move and go down
					! We end up in a well, alternating last edge: 14-17-14-17 - detected well; 17-14-17-14 - detected well; 14-17-14-17...
					+ Should detect well at second 14
					+ New issue: freezing along wall:
						! Repro: like for bounces above: vel=1.75, slightly rotated CCW (4 rotations of 3.1f * 3.0f)
						! We are at 102
						! We navigate to 137 (returning EncounteredFloor)
						! Queue: 137 137 137
						! We do non-inertial step: 102
						! We don't see 102 in queue
						! Loop
						+ Fix: 
							+ Initialize with first before machinery
							+ Update _after_ non-inertial step
						+ Verify both well issues are fixed

			+ Video
				+ Put back temporarily orig values

			+ Per-human PanicLevel [0.0f, +inf)
				+ Walking anim: when !=0 -> arms still flipping but up
				+ Adds to walking speed
					+ Npcs::CalculateActualHumanWalkingAbsoluteSpeed(humanState, labParams)
						+ Panic, Magnitude, labParams
					+ Use it wherever magnitude is used
					+ Test with max walking speed
				+ Adds (marginally) to equilibrium torque
				+ Increases converge rates for start rising
				+ Lowers time to start walking
				+ GUI slider
					+ Npcs::SetPanicLevelForAll(panicLevel)

			+ Play

			+ RenderUpload: implement
				+ F/B vs L/R geometry
					+ Front
					+ Back
					+ Left
					+ Right
					+ Test flip
				+ API calls take L/R/F/B info
				+ API also takes *quads* rather than vector+width, for perf
				+ Rendering honors L/R/F/B with shader hints
					+ depth
					+ L/R

			+ Animation improvements:
				+ Shading also at F: centered 
					+ direction basically shifts, can use it verbatim
				+ Panic arms: now they look like it's flying :-) 
					+ Try: simply flap them around vertical _up_ rather than down
				+ Panic arms at slope: npc is slow and arms also - should use time for arms
				+ Swimming
					+ Flight down should be faster
						+ Do poor man's "mod" with asymmetric interval (ifs)
					+ Also bottom angle should become more "flat" (around pi/2) when at surface
					+ Don't start until rotation is small
				+ Free_Aerial and Free_InWater - where we do "arms pointing downward": also move legs somehow
					+ When arms are at highest, legs are 100% tight; when arms are at lowest, they are X apart (same X as now, initial)
					+ Around center angle that is opposite to relvel component against perp to humanDir, with magnitude depending on that relval component magnitude
				+ Swimming: speed affected by panic
				+ Constrained_KnockedOut rearc:
					+ Double-check all transitions _to_ Constrained_KnockedOut
					+ Falling: constrain arm angles to the half-plane in the face direction
					+ Try to progress aerial to falling (rather than immediately)
						+ Also gets rid of becoming falling when hitting head
					+ Try to aerial->falling also for head 
					 @ Falling: arms should not extend perp...
						a) in air when still on the back, and 
						b) against floor when on belly
						+ Scale target by abs magnitude of head rel/abs vel along perp
						 + Fight bounces
					X Anim @ Falling: move arms towards zero depending on progress to knockout
					X Avoid arms going up when we become Falling when we're basically still
				+ Less walking in the air
					+ Could have two "distance traveled" members: one on_edge, one not on edge (exclusive)
						+ on_edge only updated with NonInertial
						+ animation for C_Walking uses linear combo of both
						+ animation for swimming uses not-on-edge
				+ Less "dead body" when KO
					+ Transition to aerial

				+ Rising improvements: 
					+ Go to "rest legs"
					+ Convergence rate = 0.2 + depth
					+ Go to "rest legs", but leg against floor does less angle
					+ Arm against floor helps body come up
					+ Arm should open w/body rising up
					+ Rethink other arm
						+ Helps first
					+ Rethink legs
					+ Try quadratic arms raise

				+ C_Aerial -> C_Falling: at this moment it makes for an ugly start, as we touch the floor and flip immediately
					+ Do transition to falling only if there's some movement of H or F
						+ Use only applicable velocity's *component along edge|H*			
					+ Need a transition to (somewhat) rising or else we'll never start walking
						+ Go to knocked out if H|F on floor but no velocity?

				+ @ Animation: check constrained-ness when we touch it

			+ * Make UpdateNpcParticle_ConstrainedNonInertial return <opt?totalEdgeWalked, doContinue> as tuple
			+ Fix mesh rendering: do not render all edges but just triangles'
				! With repetitions is fine...
			+ Do state transitions via func: TransitionState(newState, currentSimTime); func switch'es
				+ Npcs::Update takes float currentSimulationTime
				+ Uses union-structs internally for resetting & setting up (** below)
				+ Resets TotalWhateverSinceWalking and StateStartSimulationTimestamp

			+ HumanState."TotalWhateverSinceWalking" -> "TotalDistanceTraveledSinceStateStart"
				! For swimming et al
				+ Also for Free state (for swimming)
					X @ transitions (i.e. "becoming") is kinda pointless, but try to do anyway
				+ Also timestamp of state start
				+ Reset at state transitions
					+ Do state trans via func: TransitionState(newState, currentSimTime); func switch'es
						+ Uses union-structs internally for resetting & setting up (** below)

		+ Floor @ triangles

		+ Code rearcs & integration - 1 (BL only):
			! Goal: be able to copy folder of files seamlessly across FS and BL
			+ LogMessage/LogDebug -> LogNpcDebug (w/local #ifdef)
			+ Make Barylab branch
			+ Renames (files and classes)
				+ Mesh->Ship
					+ And put in Physics namespace
				+ Redo OppositeTriangles @ Triangles (array of 3)
					+ ShipBuilder
					+ Use it instead of other call: replace all calls to Edges::GetOppositeTriangle
						+ And cleanup edge element indices if we don't need them
							+ We need them to get opposite edge - store alsi this in OppositeTriangles
				+ Edges->Springs
					+ And put in Physics namespace
				+ Vertices->Points
					+ And put in Physics namespace
				+ Fuse StructuralMaterial/Database into FS
					+ Rename both to FS: Materials and MaterialDatabase
					+ Split current StructuralMaterial into:
						+ StructuralMaterial
						+ NpcMaterial
							+ Enum with all materials, as we'll be picking them in code based on NpcType
						+ MaterialDatabase:
							+ Loads two jsons (materials_structural.json and materials_npc.json)
								- Split current json
							+ MaterialDatabase: expose getters for both
								+ The getters for StructuralMaterial will stay private to BaryLab
								+ The getters for NpcMaterial will be copied to FS 
						+ NPCs takes DB
				+ "EventDispatcher" -> "GameEventDispatcher"
				+ All "BLab" -> "Game"	
				+ LabParameters
			+ Rearc source files in NpcSimulation folder
				! No namespace: some types are in GameTypes anyway...
				! Not VS GUI
				+ Npcs, Npcs_*, NpcParticles

			+ Move what used to be GameCore files to GameCore lib
				+ Then rearc all #include's for dual "section"

			+ Merge NpcParticles: FS + BL => BL
				+ Copy NpcParticles' "reservation" system from FS
					+ Integrate into Npcs::Add(...)
				+ See anything else in FS that is not in BL
				+ Finalize NpcParticles:
					+ Getter for # of free particles remaining (replaces current getter for # of particles)

			+ ~Merge Npcs: FS + BL => BL
				+ Kind hierarchy (@GameType):
					+ NpcKind (Furniture, Human)
					+ HumanNpcKind, FurnitureNpcKind
						+ Reflected into union of state structs in Npc::StateType
						! Independent from NpcMaterial::KindType
				+ NPCs container from FS (main + index, ship &, etc.)
					! Use cases:
						! 1. Reaching all NPCs of a specific ship (e.g. because of ship-wide interactions, such as electrical tool, alarm, deleting ship, etc.)
						! 2. Allow an NPC to move ships (e.g. the one "being placed")
						! 3. Reaching an NPC by its ID
					+ Design:
						+ Single vector of (opt) StateType - null'ed when removed
							+ Stable index
						+ NpcId is shipless, and an index in the above
						+ Separate vector (shipID-indexed) of opt containing vectors (indices in single vector of StateType)
							+ Also contains ShipMesh at head
						! When an NPC is moved to a different ship, its ShipId member is changed, and the ShipID "index" is updated
						+ void OnShipAdded(Ship const & ship) (from FS)
						+ void OnShipRemoved(ShipId shipId) (from FS)
					+ Decisions:
						+ Physical rendering: it is only in Barylab mode
						+ Rendering:
							+ Move NpcRenderingMode into RenderContext
							+ Probe from NPCs in BaryLab mode for Physical mode
							+ Else, upload NpcQuads (Limbs->Quads)
								- But in BaryLab's RenderContext, if Limbs vs Texture, use Limbs shader instead of Texture shader

					+ TODOs:
						+ Npcs::Update does not take Ship anymore
						+ Finish changing code for new container
						+ "Materialization" of NPC state, at:
							+ MoveParticleBy
							+ OnPointMoved
						+ "Initialization" of human, at:
							+ "Materialization" of NPC state
						+ "TODO's" in code:
							+ Npcs.h: possibly superfluous methods
							+ Publishing of behavior change at human initialization
								+ Need CurrentlySelectedNpcId, opt
									+ Auto-select from LabController at BeginPlacement, and reset at Abort


		+ Placement:
			! Spec:
				! Add: Click @ pos (w/eventual error if no room for new NPCs) -> Move -> Abort|Confirm
				- Move: Hover around (w/highlight) -> Click (picking last hovered) -> Move -> Finish
				- Remove: Hover around (w/highlight) -> Click (picking last hovered) && immediately removed

			+ Prep work:
				+ LabController start: no NPC
				+ OnShipAdded: called with Ship (we need this so that Npcs has all ships)

			+ API:
				+ opt<PickedObjectId<NpcId>> BeginPlaceNewHumanNpc(HumanKind, pos)
					+ Returns nullopt if there's no room anymore for humans
					+ Creates NPC at topmost ship in "BeingPlaced mode"
					+ Redo materialization using FindTopmostTriangle
				+ opt<PickedObjectId<NpcId>> ProbeNpcAt(pos)
					+ Returns nullopt if no NPC at position
					+ Resuscitate FindTopmostContainingTriangle
						+ Need to have PlaneId at Points
				+ void BeginMoveNpc(NpcId)
					+ Move to topmost ship - via TransferNpcToShip(..., see below)
					+ Set to BeingPlaced X 2
					+ Maintain stats & publish
				+ void MoveNpcTo(NpcId id, vec2f const & position, vec2f const & offset)
					+ Remember to calculate velocity(-ies) for particle
				+ void EndMoveNpc(NpcId)
					+ Ship finding:
						+ ResetNpcStateToWorld is responsible for finding ship
							+ Doesn't take ship anymore
							+ Callers don't need per-ship loop
					+ Update stats
						+ See OnNewNpc vs what we would be doing here
				+ void CompleteNewNpc(NpcId id)
					+ Call EndMoveNpc
				+ void RemoveNpc(NpcId)
					+Update ship indices
					+ Update stats
						+ Regime, w/publish
						+ Count
					+ Remember for LabController to ask Npcs to DeselectNpc() if it's that one
				+ void AbortNewNpc(NpcId id)
					+ Call RemoveNpc
					X Test with MainFrame key changing tool
				+ void HighlightNpc(NpcId, HighlightType)
					+ Rendering

			+ "Upload" -> "RenderUpload"

			+ PlaneId rearc
				+ Go back to Ship instead of ShipMesh, so we have GetHighestPlaneId
					+ Copy method name from FS
				+ StateType:
					- opt<PlaneId>, not set for topmost
				+ Do TransferNpc()
				+ @ ResetNpcStateToWorld: (primary's) triangle's (ship ID and) plane ID, or (topmost ship ID and) its highest plane ID
				+ @ creation/begin move: topmost ship ID and its highest plane ID
					+ PlaneId *not* taken care of by TransferNpc()
				+ @ end move: triangle's ship ID and plane ID, or topmost ship ID and its highest plane ID
					+ Taken care of by ResetNpcStateToWorld
				+ Upload PlaneId @ Render
					+ Pick topmost if nullopt
					+ Though our RenderContext doesn't use it

			+ Tools:
				+ NewNpc: polymorphic hierarchy, Human and Furniture which just differ in tiny protected method for starting					
					+ Better error cursor
				+ MoveNpc
					+ States:
						+ Hovering
							+ CandidateNpc: as long as set, it's highlighted
						+ Moving
							+ PickedObject
					+ Deinitialize: un-highlight
					+ Fix: mouse move after npc picked does not update offset
				+ RemoveNpc

			+ Follow-up NPC work:
				+ @BeginPlacement: regime is BeingPlaced
				+ Physics update: if regime==BeingPlaced: no physics steps if Human && Secondary, or !Human
					! MoveTo calculates velocity(-ies) though
				+ New "BeingPlaced" BehaviorType for humans
					+ Implicitly matches flag for secondary
				+ No stats update at begin placement & at abort
					+ Based on regime
				+ @ NPC materialization: when we decide ship, make sure we move the NPC to it
					+ ResetNpcStateToWorld() - the one that finds ship - calls TransferNpcToShip(npc &, from, to)
					+ TransferNpcToShip(npc &, from, to)
						+ Sets ship ID in NPC
						+ Maintains indices of ships
						! Does *not* worry about plane ID

				+ Stats rearc:
					+ First off, display stats @ panel
					+ Stats: remove NpcCount from stats; just do Inside/OutsideShips *but only for humans*
						+ Go through the following, updating stats and removing now superflous calls to PublishStats:
							+ All calls to PublishNpcStats
							+ BeginPlaceNewHumanNpc
								+ Just ++npccount
							+ BeginMoveNpc
								+ Stats update iff human & starting from those regimes
							+ EndMoveNpc
								+ Assert old regime
								+ Stats update iff human & falling in those regimes
							+ CompleteNewNpc
								+ Assert old regime
								+ Stats update iff human & falling in those regimes
							+ RemoveNpc
								+ Stats update iff human & starting from those regimes
							X AbortNewNpc
							+ Ship removal
								+ Stats update iff human & starting from those regimes
								+ Publish once

					+ Stats update at constrained<->free
						+ OnMayBeNpcRegimeChanged(old_regime, npc)
							+ Invoked each time after ResetToWorldState, even when we know old is BeingPlaced
						+ TransitionParticleToConstrained/Free(...)
							+ Which does it, then recalcs regime and invokes the above
					+ Avoid publishing stats for each NPC at ShipDestroy
						+ Nuke UpdateStatsOnXXX(); skeleton implemented as needed:
							! Update Free/Constrained count
							! Update count
							! Publish


				+ Animation @ BeingPlaced:
					+ Init dir=1.0/0.0 (front/-)
					+ Arms & legs: flipping between 1/4 PI to 3/4 PI with both time and distance
						+ Offset between arms and legs is random

		+ PanicLevel rearc
			+ Multiple vals
			+ HumanBehavior update: @ end:
				+ Calc resultant
				+ Decay others
			+ Use resultant where needed

		+ Merge back into master

		+ When moving head across floors, feet get stuck
			+ Isn't it enough to make both particles free?

		+ Other animation improvements:
			+ See if we can change NPC's first state after placement from KO'd to Aerial
			+ Aerial: 
				+ Try 1: arms are always "up" in direction of head, but a bit less so when NPC is horizontal
				+ Transitions out:
					+ If enough time (very short, 2-3 frames) constantly with:
						+ a: foot on edge
						X b: reasonably vertical
						+ Then: go to rising
					+ If enough time (quite short, > 7 frames) constantly with:
						+ a: foot on edge
						+ b: relvel "falling down" (away from vertical)
						+ Then: go to falling
			+ Aerial: arms are up too soon - make them go there slower
			+ Falling->Aerial (i.e. when on the floor and bouncing up): faster
			+ FIX: ending move makes arms start from scratch; need continuation of human state
			+ Aerial: lower arms when foot on the floor
			+ Walking: arms aperture depends on walking speed (when not in panic mode)
			X Aerial: upon impact, rotate face direction by one
				X If looks good, use somehow also at swimming
			+ Transition between Free_InWater and Free_Swimming should be smoother
				+ NPC starts swimming too quickly
			+ Walking: 
				+ Realize earlier than we're falling - but don't confuse with little bump
					! Acceptable down V: -6.12
					= Can relax: if we're walking at normal speed, our tolerance to vert V could be very small					
				X Fix: when very fast and up a slope, we do little bump (which is OK) but then when we land we bounce and thus flip
					! OnImpact(0.0341793, (-0.606217503548, -0.795298933983)); velocity=(-3.19136810303, 2.45355224609)
				+ Fix: when very fast, we lose equilibrium too much because feet start fast and head not => StaticDisplacementAngleCW becomes large
					+ More tolerance
			+ Swimming:
				+ Initial pause while gathering limbs
				+ Multiple styles:
					! This one
					+ Trappelen (leg lengths) together with arms
					+ Trappelen (leg lengths) with one arm above
			+ Try crotch offset updated while walking
				! Completely animation-based
				+ UpdateAnimation has new member: ~"crotch height adjustment"
					+ Updated based on locally-calcuated leg angle
				+ RenderUpload calcs human points taking ~"crotch height adjustment" into account
			+ Fix: when in Free_Aerial and floating, it never goes to swimming

		+ HumanNpcLengthAdjustment
			+ Use @ spring force calc'ns
				+ At adjustment change detection: update all humans' DipoleLength's
			+ SettingsDialog
			+ Initial dipole state
			+ Fix: torque calculation currently hiddenly depends on dipole length; needs to become independent from it
				+ Symptoms: small man always flips, small human never rises once KO'd
		+ Randomize human height
			+ HumanState::Height member init'd with gaussian - see real distribution params
			+ Replace all accesses to GameParameters::HumanNpcGeometry::BodyLength with this member
			+ Influences also walking speed
				+ GameParameters: "base" + "adjustment"
					+ SettingsDialog
				+ HumanState::WalkingSpeedBase (const) member init'd here
				+ Replace all accesses to GameParameters::HumanWalkingSpeed with this member
				+ Check high and low speed
				+ Check tall and short adjust

		+ Stop "hanging head" issue
			! We want to allow feet (primary) constrained and head (secondary) free, as secondary is allowed to become constrained
			+ Rearc:
				+ 0. Test pri/sec free and other not				
				+ 1. When pri becomes free, sec becomes also free
					+ @ TransitionParticleToFreeState
					+ Test:
						+ Head flying off while feet on ship: stays in-ship
						+ Feet flying off while head on ship: whole becomes free
				+ 2. IsEdgeToFloor: taken care of by tessellation, including "sealed but crossing makes free"
					+ Make test mesh and check current behavior
					+ 2a. Reduce IsEdgeToFloor to just check surface type; verify broken
					+ 2b. Do at tessellation
						+ Triangle's subedge is floor if:
							+ Edge is floor, and
							+ Not is sealed, or (is sealed and) there's no triangle on the other side of this subedge
					+ 2c. Test:
						+ Temporarily remove call to other function
						+ Head/feet in sealed triangle, internal
						+ Head/feet in sealed triangle, on border to free
				+ 3. Other func: verify is broken now w/sleeping giant; fix w/TODO
					+ Separation + human vertical
				+ 4. Rewrite floor check
						+ Nuke & replace with direct check for surface type
				! Plan B: ray-trace from sec'ry to pri'ry, if no more edges found (other than the edge that the sec'ry is on): not a floor
			+ Cleanup

		+ Test with single particle ("furniture")

		X See if can get rid of floor type @ Springs

		+ Leg length also should be adjusted w/crotch
			+ After all: crotch is down, hence leg is also down now
		+ No buoyancy while being placed

		+ Video
			+ Things to show:
				- Placement
				- Walking
				- Rag doll
				- Many humans
				- With ship movements
				[]
				- Panic
				[]
				- Swimming - when many, so we show different styles

	+ Prepare for optimizations
		+ IN_BARYLAB defines BARYLAB_PROBING
		+ Use BARYLAB_PROBING around various publishing code
			+ Test compiling w/out IN_BARYLAB
		+ Add PerfStats
			+ NpcSimulation time (take naming from FS)
			+ Display
		+ Add RenderUpload to PerfStats
			+ Separate measurement, separate output
		+ Add mechanism for jumpstarting with 100's of human NPCs
			+ Npcs::Add (== BeingPlace+EndMove)
			+ Call from LabController @ initialization
		+ Initial measurement: 
			+ 1024 human NPCs, all walking:
				- Update: 0.34ms
				- RenderUpload: 0.25ms
			+ 8192 human NPCs, all walking:
				- Update: 2.7ms
				- RenderUpload:  1.9ms
				
	+ Optimizations:
		+ Run perf analysis

			++++++ Initial
			+ Npcs::UpdateNpcs: 41.33%
				- Npcs::UpdateNpcParticlePhysics: 19.08%
					- Npcs::CalculateNpcParticleDefinitiveForces: 5.29%
						- atan2f: 2.36%
				- Npcs::UpdateNpcAnimation: 9.84%
				- Npcs::UpdateHuman: 5.55%
				- Npcs::CalculateNpcParticlePreliminaryForces: 2.53% => 2.41%
			+ Npcs::RenderUpload: 45.22%
				- Npcs::RenderNpc: 30.63%
					- RenderContext::UploadNpcQuad: 21.31% => 18.04%->18.25%
			++
			+ sin: 5.39%
			+ atan2f: 4.34%

			++++++ Interim 1
			+ Npcs::UpdateNpcs: 38.86%
				- Npcs::UpdateNpcParticlePhysics: 18.90%
					- Npcs::CalculateNpcParticleDefinitiveForces: 5.24%
						- atan2f: 2.25%
				- Npcs::UpdateNpcAnimation: 8.38%
					- atanf: 1.02%
				- Npcs::UpdateHuman: 5.19%
				- Npcs::CalculateNpcParticlePreliminaryForces: 1.83%
			+ Npcs::RenderUpload: 41.76%
				- Npcs::RenderNpc: 28.27%
					- RenderContext::UploadNpcQuad: 20.18%
			++
			+ atan2f: 4.75%
			+ atanf: 1.02%
			++
			+ Measurements 2.5/2.6, 1.2

			++++++ Interim 2 (equilibrium torque)
			+ Measurements 2.4, 1.2

			++++++ Interim 3 (equilibrium maintenance, last atan)
			+ Npcs::UpdateNpcs: 42.22%
				- Npcs::UpdateNpcParticlePhysics: 20.98%
					- Npcs::CalculateNpcParticleDefinitiveForces: 3.52%
					- ToBarycentricCoords: 2.10%
				- Npcs::UpdateNpcAnimation: 10.23%
					- atanf: 1.01%
				- Npcs::UpdateHuman: 2.93%
				- Npcs::CalculateNpcParticlePreliminaryForces: 2.28%
			+ Npcs::RenderUpload: 33.77%
				- Npcs::RenderNpc: 22.69%
					- RenderContext::UploadNpcQuad: 14.66%
			++
			+ atanf: 1.01%
			++
			+ Measurements 2.3, 1.1/1.2

			++++++ Interim 4
			+ Measurements 2.1/2.16, 1.1/1.2

		+ Update:
			+ CalculateNpcParticlePreliminaryForces:
				+ Precalc most spring force factors
					+ Figure out what to do with BaryLab's specific parameters (gravity adj/gate, mass adj)
						+ 1. Npcs own the BaryLab-specific params (GravityAdj/Gate, MassAdj)
							+ Out of GameParameters, and LabController sets them in Npcs
							+ Members are in #IN_BARYLAB
						+ 2. Npcs: upon getting changes, stores in members and calls RecalculateSpringForceParameters()
						+ 3. Npcs::RecalculateSpringForceParameters:
							+ Calcs with common params first
								+ See if in FS we take these as args or use the mCurrent values
							+ Then if #IN_BARYLAB multiplies by adjustments
						+ 4. Update: upon detecting param changes, calls RecalculateSpringForceParameters
						+ Test:
							+ Mass
							+ Gravity
							+ Spring 1
							+ Spring 2
			+ UpdateNpcAnimation:
				+ Try with calculating cos & sin once there (after target angle calc'n) and reusing those @ multiplier calculation _after_ target angle
					+ Count first
					+ New sub-struct: AnimationState
					+ UpdateAnimation()
						+ Use cos/sin @ Walking/LegMult
					+ RenderUpload()
				+ Those "TODO" optimization while walking
				+ Fix edge/cross thing
					X Option 1: NavigateVertex after bounce @ NonInertial, if on a vertex
						! Too complex, requires calc'n of new traj end which itself depends on bounce response velocity
					X Option 2: no adjustment if negative
					+ Option 3: limit lambda
				+ Vectorize target progress
				+ Traverse dir's do redundant normalization
					+ F/B
					+ L/R
			+ Own sincos_p4 from http://gruntthepeon.free.fr/ssemath/sse_mathfun.h
				+ 1. Merge GameMath
				+ 2. FS: UnitTests
				+ 3. FS: Benchmark
				+ 4. Impl
					+ Verify assembly for those constant loads
					+ See if can use 4f constants elsewhere
				+ 5. Use in BaryLab
					+ Make AnimationState members as vectors4
			X Own atan2
				+ Merge vectors
			+ See if can do without atan2
				+ CalculateNpcParticleDefinitiveForces: radial rearc: similar to springs:
					+ Torque force is radial, and resultant of two components:
						+ 1: Hookean force proportional to length of arc to destination, directed towards the ideal head position
							- But we approximate the arc with the chord, i.e. the distance between source and destination
								- Source is *predicted* source
						+ 2: Damp force proportional to component of relative velocity that is orthogonal to human vector, opposite that velocity
					+ If ok:
						+ Cleanup/Optimize
						+ Test:
							+ Panic
							+ Different human height
				+ CheckAndMaintainHumanEquilibrium: work with cos (i.e. dot) and cross
					+ Angle wrt vertical: use y component of normalized vector (+1.0 if fully vertical, i.e. cos); we're out if y < cos(MaxAngle)
					+ Angle rel vel: 
						+ We're out (diverging) if RV dot perp(humanDir) < or > 0 depending on whether H is left or right of IH
							+ => out iff RV dot perp(humanDir) * (IH.x - H.x) > 0
					+ Also calc RV only if needed
			X See SSE load immediate
			+ Make limb vectors aligned 
				+ Change loadu/storeu back to a - Algorithms and GameMath
			+ RenderUpload: should not need any normalization()
			+ Various normalize() -> approx
				+ RenderUpload Quads
				+ Equilibrium torque
				+ Walking: limb-on-edge constrains (angle+length)
				+ Falling limbs
				+ Rag-doll limbs
				+ Equilibrium maintenance
				+ 2.2/1.2
			+ See if there are any ray-tracing bcoord conversions that are redundant if we have abs positions
			+ Fix walking speed adj changes not picked up
				+ Test panic
			+ The TODO:perf at walking
			+ See why flipping walk when on slope and mesh rotates
			+ Inline various simulation funcs
				+ NavigateVertex
				+ Bary coords
				+ 2.1/1.2
			+ See if can do without atan @ UpdateAnimation - Constrained_Walking
				+ 2.1/1.2
			+ Fix: going through wall - repro: all humans, slight inclination
			+ Fix: getting stuck - repro: all humans, slight inclination
				! Definitely due to epsilon too small: got a case with -1.00127444e-07/-1.45286322e-07
				+ Algo for "other side of edge":
					+ InternalCalc takes vertex ordinal "anchor" and two other vertex ordinals (as non-anchors)
					+ Calc coords using any of not-edge as anchors (=> edge is one of the two coords calc'd)
					+ Then clamp edge and calc 3rd coeff via 1-...
				+ Cleanup
			+ See if can get rid of IsOnFloorEdge - by using CurrentVirtualEdge
				! IsOnFloorEdge() is currently used for:
					- Human behavior update: transitions depend on whether feet/head are on edge
					- Human animation update: rag doll, etc.
				! As long as CurrentVirtualEdge is only and always set when we know we're on an edge (ConstrainedNonInertial)
					- At this moment it's set _before_; we need to set it _after_, reflecting actual situation _after_
						! Current impl seems broken when we bounce
						- Initialization - as "free"
						- After ConstrainedNonInertial, where we may be:
							- Still non-inertial, (but might be on a different triangle and thus different edge, but definitely on an edge)
							- Have become inertial (so not on an edge)
							- Have become free (so not even constrained)
							- SO: just use edge if at exit we're constrained *and* on an edge
								- TODO: no this is broken, 1) when we're at a vertex
								- TODO: see solution on notebook
						- After ConstrainedInertial:
							- Always "free" (-1), as we only decide we become on an edge @ ConstrainedNonInertial
						- Free: assert it's -1 (actually, does it even exist?)
					- While we're here: see if ConstrainedNonInertial can rollback current tri/coords at bounce, so we can get rid of "vertical edge" issue
						- But then see effect of this change on gravity well
				+ Impl:
					+ Undo cur changes - diff first!
					+ GameTypes: TriangleEdge (TriangleElementIndex, EdgeOrdinal)
						+ Never "None" indices/ordinals
						X Also replace in well detection machinery
							! That one has bary coords
					+ CurrentVirtualFloor: opt<TriangleEdge>
					+ Do code changes
						+ Mostly cosmetic, with the only change being the triangle being correct now
					+ Verify walk-bounce animation behavior now (legs angles & lengths)
					+ Try with older (higher) convergence rate now
					+ IsOnFloorEdge: see if may nuke it & replace with check for CurrentVirtualFloor
						+ Do parallel+check first, with logging
						+ Some dynamics have changed, see if for better or worse
							+ Set current_virtual_floor at *inertial* bounce - after all it's a floor edge we're on at that (infinitesimal, frame) moment
				+ Tests:
					+ Constrained_Aerial -> Falling (feet or head have V)
					+ Constrained_Aerial -> Rising (no V)
					+ Animation of rising: helping leg/arm
					+ Animation of walking: leg lengths and leg angle limits
				+ Cleanups:
					+ Nuke IsOnFloorEdge
		+ Bary coords:
			+ Check assembly
			X Can do two coords in parallel via SIMD?
				X Move to Algorithms, then add unit tests (all of this in FS first)
			= Read https://fgiesen.wordpress.com/2013/02/10/optimizing-the-basic-rasterizer/
		+ RenderUpload:
			+ Pre-alloc quad buffer
			X UploadNpcQuad force-inlined
				! Didn't change anything
			+ Analyze asm
				+ Lots of things seem optimizable, make sure compiler has optimized them
			x Vectorized rotation
				! Broadcast first actualBodyVDir.x to __m128 x and actualBodyVDir.y to __m128 y
				! Sin and Cos are already vectors
				! xx[0] = x[0]*c[0] - y[0]*s[0]
				! yy[0] = x[0]*s[0] + y[0]*c[0]
				! L Arm is (xx[0], yy[0])
				! ...
				X Do at:
					X F/B
					X R/L
			X BoundedVector: find way to reserve+take_pointer+advance pointer; see if improves
				X Doesn't change anything
			+ Index work to lower # of vertices per quad
				+ Use at RenderContext

		+ Profile swimming (free regime)

	+ normalize_approx
	+ Some more randomization of behaviors
		+ -1...+1
		+ BeingPlaced
		+ KnockedOut->PreRising
		+ PreRising->Rising
		+ See with 8K NPCs
	+ shorter time to converge walking magnitude to 1.0
	X Problem with running up a slope (messy stumbling): it's due to the human angle becoming too low, after feet bounce on floor
		+ There isn't much to do here?
	+ Better rising animation
		+ New arm
			+ Try to move arms earlier
			+ Accept and cleanup 
		+ Try both legs bent
			+ ThighLegLengthFraction member
			+ ThighFraction: "nothing" is 1.0, and RenderUpload does UpperLeg always with that length
				+ @ member
			+ AnimationUpdate:
				+ At beginning: set to 0
				+ At walking: <see notebook>
				+ ThighFraction default is 1.0
				+ New ThighFraction values dynamics
				+ Do ThighFraction and leg angles only if L/R
			+ RenderUpload:
				+ Carve room in ShipRenderContext for thighs
					+ Decide whether we want to precisely calc or overshoot instead
						+ Though that would cause more churn in BoundedVector
						+ Decided: overshoot
				+ Do legs with if depending on ThighLegLengthFraction
				+ Only when sideways
				+ Do UpperLeg always (preliminary quad), using ThighFraction
					+ And lower leg (opt) iff 1.0-ThighFraction > 0.0
				+ Calc traverse vector for lower leg
			+ Straight legs earlier
			+ More separation between two legs - until when we zero angles out
			+ Increase arms angle
			+ Introduce Constrained_PreRising state:
				+ HumanBehavior state update: 
					+ Conditions to stay: same as KnockedOut
					+ Conditions to go to Rising: same as KnockedOut
				+ Go to PreRising instead of Rising
					+ Only from KnockedOut
						! Aerial->Rising is not suitable
						X Others?
				+ AnimationUpdate:
					+ Arms: angle towards PI/2 and length multiplier towards 0.0
				+ Rising animation:
					+ Arms: 
						+ Early stage: length multiplier towards 1.0, and angle fixed ad where it is (PI/2)
						+ Late stage: no length multiplier, and angle like now
					! Legs: unchanged
				+ Replace angle-taking at PreRising with alignment with floor (dot><0)
				+ Replace PI for HumanAngle at Rising with negative
					+ Basis
					+ Optimized
					+ And complete arm length multipliers @ Rising
				+ Improve arm length recoil at rising
					+ Make it touch floor - use pseudo tan
				+ See how Constrained_Aerial->Rising transition looks like
			+ Animation knees: do case where we're facing away from floor
				+ Facing away from floor: iff face_dirx <> left case or right case
				+ Simply opposite angle for legs?
		+ Reduce rising speed
			X 1. More damp: >= 0025
			X 2. Torque relationship wrt head-idealhead distance: sub-linear (less when distance high - so rises slow - and more when small - so converges earlier)
				- Use a quadratic relationship anchored to current force we get at say PI/4
			+ 3. Less stiffnes: 0.0044 -> 0.004
	X See if slow growth of thigh is really needed - can do 0.5 right away (and thus constant the whole time)?
	+ Pass texture coords @ RenderUpload (as stand-in of future real textures, but improving knees with current shader)
		+ Do special for knee - calc based on upper/lower lengths
		+ Try with quad joint
	+ Fix issue with first frame of Rising on sloped floor
		! Due to:
23:55:17.525119:humanEdgeAngle1:-8.11901e-06 !!! This is supposed to be 0.0
23:55:17.525342:humanEdgeAngle2:3.14158 isOnLeftSide:1
23:55:17.541765:humanEdgeAngle1:-8.11901e-06
23:55:17.541927:humanEdgeAngle2:3.14158 isOnLeftSide:1
23:55:17.557376:humanEdgeAngle1:0.00420773
23:55:17.557538:humanEdgeAngle2:0.00420773 isOnLeftSide:1
		! And we need the adjustment because of: (when facing right)
00:01:31.062011:humanEdgeAngle1:-3.14159 !!! This is supposed to be +3.14
00:01:31.062248:humanEdgeAngle2:-3.14159 isOnLeftSide:1
00:01:31.077365:humanEdgeAngle1:-3.14159
00:01:31.077609:humanEdgeAngle2:-3.14159 isOnLeftSide:1
00:01:31.092681:humanEdgeAngle1:3.13885
00:01:31.092874:humanEdgeAngle2:0.002738 isOnLeftSide:0
00:01:31.108497:humanEdgeAngle1:3.1336
00:01:31.108717:humanEdgeAngle2:0.00799489 isOnLeftSide:0
00:01:31.124679:humanEdgeAngle1:3.12604


	- Test rising on slope
	- Test mesh spikes (head/feet)
	+ Lower max speed
	+ Lower human elast
	+ Add velocity damp
		+ When free
		+ When constrained (*)
			! Problem 1: needs to be only relative velocity part to be damped, not mesh velocity
			! Problem 2: only secondary has torque velocity, so we'd always apply damping to primary (feet)
				- Can solve with check on human behavior (one of those three behavior types)
			+ Rearc:				
				+ 1: replace NpcParticles' Torque buffer with HumanState::EquilibriumTorque (float)
					+ Reset at UpdateHumanBehavior
					+ Set when we currently set it
				+ 2: apply torque conditionally at CalculateDefinitiveForces():
					+ If Human && EquilibriumTorque != 0.0 && is secondary
				+ Test & commit
				+ 3: apply damp:
					! General principle: damp should only apply to relative velocity (relative to mesh)
					+ At all velocity calculations (both pri+sec), but only if NOT (Human && EquilibriumTorque != 0.0) 
						! Because damp kills equilibrium, as secondary doesn't gain enough velocity from walk
						+ Apply to non-mesh portion of absolute velocity
					+ Include bounce velocity (because it's calculated from new absolute) 
						+ But only to relative velocity part (same trick - removing mesh velocity?)
					+ Except gravity well velocity (because mesh velocity is not to be damped)
				+ Tests:
					+ Jumping while ship is in motion: damp should NOT apply (as relative velocity is zero)
		+ Add slider
	+ See if now recovers from hanging on feet
		+ Requires velocity damp work above (*)
		+ Also has new problem: head hitting floor when rising up
			! Because indeed angle is not "quite vertical", so we consider it a floor
				! y is actually 0.6: even opposite sign of what we consider "quite vertical" for the purposes of "hanging head (w/head on top)"
			+ Fix: HumanBehaviorUpdate-@KnockedOut: when we decide time is ripe to transition to Rising:
				+ Before doing the transition to Rising, check condition to detect hanging-by-feet: 
					+ Feet on floor, head not on floor, and reasonably vertical heads down
				+ If condition met: set primary's "GhostParticlePulse" to true
					+ Else: go to rising, as before
				+ GhostParticlePulse:
					+ Init'd as False @ beginning of HumanBehaviorUpdate (just like EquilibriumTorque)
					+ Check it @ IsFloorToParticle()



	+ Random width
		+ Skew: thin stddev 0.05, fat 0.15
			+ And cap for safety
	+ Randomize to-rising convergence rates
	+ Wave simulation

	+ Note: LogDebug/NpcDebug evals args - have Log.h defined as macro
		+ Do
		+ Integrate into FS - and test build

	- Video

	- Integration into FS - 2
		! Goal: be able to copy folder of files seamlessly across FS and BL
		- Triangles: add BL features
			- Barycentric math (replace FS')
			- SurfaceType
			- OppositeTriangle
			- etc?
		- GameTypes: BaryLab->FS
		- Move Npc simulation source files under NpcSimulation folder
			- Not VS GUI, that's still "Physics"
		- Port NpcMaterial.* and NpcMaterialDatabase.* into Materials.* and MaterialDatabase.*
		- Port GameParameters settings that we need
		- TODOHERE
		- Settings:
			- SettingsManager
			- SettingsDialog

	+ Remaining state machines:
		+ See above for "Impact" responses at the various states 
			+ There is remaining (=) work above for this!
		+ State::Free_Aerial: (was: FreeKnockedOut)
			+ We transition here at UpdateBehavior, NOT at BecomingFree!
			+ Becomes InWater if both points in water
		+ State::Free_InWater:
			+ Converges towards Free_Swimming by going to target==head_vel.normalize().dot(human_vector.normalize())
			+ Becomes Aerial if no points in water
		+ @ Becoming free: decide between Free_Aerial vs Free_InWater depending on OceanSurface
		+ State::Free_Swimming:
			+ Becomes Aerial if no points in water
			+ Animation
		+ Impacts:
			+ At each impact, call OnImpact(...particle..., ...impact quantities...)
			+ OnImpact: if human, check state machine and do following transitions:
				+ If walking and impact V (velocity of particle along normal) is in direction of walking:
					+ Flip direction
			
	- Other walking features:
		- See if can detect that will hit a wall/well by projecting forward primary particle along immediately following triangle edge; if will hit, turn around
			- Note: detect both slope up (requires "globalizing" the max slope constant) and slope down
			- Impl:
				- WalkingBehaviorState: new member: ElementIndex (or TriangleEdge?)) LastPlanTriangleOrigin, init'd as None
				- Walking update: if triangle != LastPlanTriangleOrigin:
					- Find next floor in cur triangle along walking direction
						- CanProceedInDirection(TriangleEdge, xDir) -> bool
							- xDir translated into CCW or CW, then proceeds with analytical vertex finding until floor
					- TODOHERE - also include random choice of whether to fall or not
					- TODOHERE - also at initial direction choice
					- LastPlanTriangleOrigin = triangle
					

- Tessellation changes to allow slopes left and right
	- Test if FS is ok with it:
		- Frontiers
		- Anything else?
	- Test if BaryLab's triangle navigation algo's are ok with it
	- Plan B:
		- "staircases": floors can be marked as "stairs", and that is used in two places:
			- Bounce detection: when walking, no bounce regardless of slope (do continuation case)
				- Only when we're walking
			- Walk vector flattening: forcibly extend walk along edge, even if exactly orthogonal
			- Auto-build: when two three consecutive edges wind up to 360 degrees

- NpcDatabase:
	- Spec:
		- Provides info on humans (e.g. role colors, frame IDs) and furniture (dimensions, orientation, frame IDs)
		- Two sections, each own schema:
			- Humans
			- Furniture
		- json refers to frames by name, but cctor - which also takes texture DB - stores references (or even directly coords!) by numeric ID
		- Allow for mergning of multiple "packs"
			- So SubKind domain is expandable at runtime
		- Also affects UI (for menu with list of subkind names, which might have multiple languages)
		- Problem of quad dimensions (currently dictated by GameParameters::HumanNpcGeometry) vs texture frame dimensions:
			- Could solve this by fixing, at DB init time, one of the two frame dimensions and calculating other based on frame dimensions
	- Details:
		- NpcSubKindId: uint
			- TODO: want to differentiate btwn NpcKind's?
		- Humans:
			- (NpcSubKindId) -> TextureCoords, colors
				- TODO: initialization gets texture DB to populate this
			- (NpcSubKindId, Language) -> Name
		- Furniture:
			- (NpcSubKindId) -> TextureCoords
			- (NpcSubKindId) -> IsDipole ? (Length, Width, Orientation, ...)
			- (NpcSubKindId, Language) -> Name

- Rendering:
	- Atlas textures are aligned with HumanNpcKindType and FurnitureNpcKindType, e.g.:
		- HumanNpcKindType:
			- Passenger = 1
			- Captain = 4
			- Officer = 7
		- FurnitureNpcKindType:
			- Table = 8
			- Chair = 9
		- For humans: adding 0, 1, and 2 gives front, back, and side
	- NPCs will have two sets of vertex attributes:
		- Static ones: contain static properties (colors - incl, highlight, texture coords)
			- Only reloaded at e.g. NPC insertion/removal, or when face direction of at least one NPC changes, or when highlight of at least one NPC changes
				- Face direction changes done via single helper, which also marks "static render attributes dirty" (a single Npcs-wide boolean)
		- Dynamics ones: contain things that change at each frame (world vertices, )
	+ Use indices for quad vertices
		+ Good use case to experiment with the "quad single index buffer" feature
	- NpcType needs an associated per-NPC NpcOrientation, because the way a quad is laid out around the particles for a human is different than that of a table
		- Uhm: after all a table is not that simple - think when flipping it
	- Quad shader:
		- Discard  when transparent
			- But only after testing with two connected components - & inverse order of drawing; should bug out when near NPC is drawn before far NPC and they are on top of each other
				- Requires following their triangle

- Physical Interactions:
	- Make sure triangle destruction is forwarded to NPCs
		- Any constrained NPC on a destroyed triangle becomes free
	- Swimming humans generate bubbles
	- Humans on air-water interface generate small waves
		- Need to produce as side-effect: Swimming humans generate small waves
	- Lights: second pass of lighting algorith with all NPC particles, for each ship
		- Adding to NPC particles' _light_ buffer
	- Fire:
		- When <TODO> vertices of triangle are on fire, NPC catches fire as well
			- Rendering: Ship asks Npcs (via World) at RenderUpload time, so that flames are in same buffer
				- Need count and Npcs::RenderUploadFlames(...), both by Ship
	- Wind: all ships, only in free regime
	- Ship-specific explosions: only of that ship, or free regime
	- Swirl, etc.: all ships, all regimes
	- Move tool:
		- While MoveAll may be used to move everything, Move (component) only moves mesh, thus subjecting NPCs to apparent forces!
	- Electric spark:
		- Electrification must be stored with Points
		- NPC update looks at own triangle's Points
	- Doors:
		- Triangle edge/floors: split "factory" vs. "actual"
	- NPCs add mass to particle
		- Ship::Update asks NPCs (via ParentWorld) to add themselves to Points' (definitive) masses

- Layers:
	- Overall design:
		- There are floors and there are stairs
		- When *in walking state* and arriving at a vertex at which there are more than two *viable* floors there (incl. incoming, so >= 2+1), choose which one to take
			- Note: *viable* == with right slope for walking on it
			- Perf: triangle vertices (or points) remember the # of floors connected to it *at factory time*, so we can avoid doing the check when e.g. it's a simple junction among two floors
		- Mechanics of check for existance of floors:
		

		- OLD:
		! Axiom: a wall is not a floor, and a stair is neither
		- Floor edges are one of three types:
			- S: stairs (diag)
			- H: horiz
			- V: vert (TBD: H/V distinction really needed?)
		- When on H or V: if arriving at S and there are more than two *viable* floors there (the incoming, the S, and another H (e.g. floor continuation) or V): choose whether to take S or the other H/V
			- Note: *viable* == with right slope for walking on it
			- TODO: do we need to make a distiction for where we're coming from? Can't we also choose if we come from S?
		- When on S: a H in the same triangle is transparent (case of hitting ceiling with feet when going up the stairs)
			- And when primary on S, any H is transparent to a secondary (to overcome head being triangles away from feet)
				- Both of the above only if *walking* - otherwise cannot fall between S and H
			- But the V is still very much floor, NPC hits but it's ok (it's a wall after all)


	- Floorplan layer:
		- A specific "FloorPlan" layer provides a bitmask indicating points' (and thus, springs') floorness
			- Technically, it's a mappping between *pairs* of Points and the FloorType enum
			- Floor types:
				- TODOHERE: see how overall design works
				- "Manhole": from L/R/T/B
					- Might not work as-is; needs to say that a side of a triangle is "transparent" if approached CW or CCW
				- In the future, also "floor areas"
						
		- When the layer is absent, the layer is created automatically (@ ShipFactory) with the hullness of particles
			- Algo for creation should take care of following aspects:
				- Make sure walls not too crowded
				- Make sure there are stairs (evt. creating them)
	- Interior layer
		- A new texture layer
		- When the layer is absent, it is created automatically (@ShipFactory) from the structural layer (+ material texturization if enabled)
	- Both layers make up the "Interior view"
	- User can choose between "Exterior" view and "Interior" view, via menu
		- While an NPC placement tool is selected, the game switches temporarily to "Interior" view, regardless of current setting

- Sounds:
	- Like we do with others: NpcMaterial has (own) SoundType property
	- Human events:
		- Hit (@ bounce), Exclamation (@ loss of equilibrium)

===================
Next release:

- Rendering:
	- Knee when rising: flatten it (extra triangle)