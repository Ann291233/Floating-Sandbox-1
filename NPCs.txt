NPC Overview
===========

NPCs are of (at least) two types: humans, and furniture. Human NPCs have an AI and move on their own; furniture NPCs are simply static.


NPC Physics
===========

An NPC is represented by one (or more) particles, exactly like all the other particles in FS. The way the NPC particles move depends on the "regime" or "state" in which an NPC finds itself at the moment. There are two possible "regimes".

** Constrained Regime **
This is the initial regime, when the NPC is spawn. In this regime the NPC particle is constrained to move within triangles of the ship, and the particle's movement is the resultant of the NPC's own movement (e.g. walking), friction along "floor" sides of the triangles, counter-gravity generated by "floor" sides of the triangles, and any external forces (including gravity). As an example, when walking on an almost-flat horizontal side of a triangle, gravity has little effect and the NPC moves freely. As soon as the spring becomes too steep, however, gravity wins and the NPC "slides" down the spring.

In the Constrained Regime NPC's normally walk along the springs of the "Paths" layer, i.e. springs of the ship that are also present in the Paths layer. These springs make up the paths that NPC's walk along. However, NPCs may eventually lose their path, for example when at the end of a path or when the path becomes too steep. When this happens, they fall along the ship springs according to gravity, until they reach a path spring again.

An NPC remains in the constrained regime until it reaches a "hole" point, i.e. a point through which normally water would enter. When this happens, the NPC enters the "Free" regime.

** Free Regime **
In this regime NPC's do not follow paths, but rather move freely according to particle physics. They fall when in air or sink, rise, and float when in water. Once in this regime, the NPC stays in this regime.

This regime has a few sub-states controlling the actions and the rendering of the NPC, and a separate algorithm governs the transitions between these states. The states are:
- Floating: the NPC particle is stationary on the sea surface; the NPC might be rendered as asking for help with its arms and moving its legs to stay afloat.
- Sinking: the NPC particle is sinking towards the bottom of the sea; the NPC might be rendered as rotating with limbs moving in arbitrary directions.
- Rising: the NPC particle is underwater but rising towards the sea surface; the NPC might be rendered as swimming upwards.

NPC particles are made of one of few new "NPC" materials, for example "Human NPC", which simulates human mass and buoyancy when breathing, resulting in a particle that would normally *barely* float. If arbitrary transitions between the three states are required - e.g. a floating NPC should start sinking all of a sudden - these will be implemented by means of forces added onto the particles.

NPC Rendering
===========

The particle of a "Human" NPC is considered to be its feet. An additional particle - the head - is attached to the feet via a spring, and only used for rendering purposes. This allows for bending and angular momentum.
This additional particle's mechanical physics is updated at the same loop as the main particle's mechanical physics, but doesn't participate in anything else.
If the concept works fine, we can enhance it later with additional springs for limbs. We will begin with one single particle though.

The two particles define a simple elongated quad. This quad is then rendered with textures, from an atlas containing all NPC frames.
The texture groups' are the "movement types" (e.g. "walking", "falling", "swimming", etc.) (together with furniture NPC types, such as "table", etc.). Each movement type has 1 or more frames, numbered consecutively.

Color coding:
- TODO: https://www.reddit.com/r/gamedev/comments/3215xb/replacing_texture_colors_in_opengl/
- texture3d: 
	- Basics: https://stackoverflow.com/questions/20012676/glsl-change-specific-color-of-texture-to-another-color and https://www.reddit.com/r/opengl/comments/1x2rq1/how_can_i_replace_one_color_from_a_texture/
	- To create LUT table: http://kpulv.com/359/Dev_Log__Color_Grading_Shader/

Frame rules:
1. Frame size is 64x64
	Max 4096 frames
2. Try to maximize canvas usage. Ideally, for the "standing" frame, the feet touch the bottom edge, and the topmost pixel (above the head) touches to top edge
3. Each frame will have to be duplicated for man and woman appearances
4. We're going to use color coding. Basically, some of the colors in each frame will be changed at rendering time to allow for differently-colored uniforms for different roles.
	So for example we can have role-specific colors for the pants/skirts, jackets/shirts, and if we want, stripes on the arms and/or legs, and hats
	Like at https://www.reddit.com/r/gamedev/comments/3215xb/replacing_texture_colors_in_opengl/
4a. Background has to be full white (255, 255, 255)
	If we need actual white in the frame, we can use a slightly darker white
4b. (and this part I still have to think through completely, but we can start with this)
	You may use any colors you want, but these are special and will be replaced by role-specific colors
	medium red: 128, 0, 0: upper body (shirt/jacket)
	light red: 255, 0, 0: lower body (pants/shirt)
	medium green: 0, 128, 0: shoes
	light green: 0, 255, 0: hat
	medium blue: 0, 0, 128: unassigned at this moment (don't use)
	light blue: 0, 0, 255: unassigned at this moment (don't use)
5. Walking frames: 
5a. 3 frames (1: left leg ahead, 2: both legs vertical, 3: right leg ahead)
5b. The upper body vertical axis needs to be horizontally centered and needs to stay aligned vertically - basically, the animation needs to look fluid if you alternate the three frames always at the same position

Details
===========

- Type hierarchy:
	- NpcType:
		- Human
			- HumanNpcRoleType:
				- Passenger
				- ...
		- Furniture
			- FurnitureNpcType:
				- Table
				- ...

- In the constrained regime:
	- A particle always belongs to a triangle
		- And its world coords can be translated back and forth into barycentric coords wrt the triangle
		- As a special case, the particle may strictly belong to a *side* of that triangle, in which case we assume it's walking on it
			- We can store a "sticking" boolean to remember it's attached, though it's simply a special case of barycentric coords saying it's on a *side*
	- Core of the simulation of an NPC:
		- Starting point:
			- SW: World coords: current coords
			- SR: Relative coords: barycentric coords of SW in old "state of triangles" (which may just be stored at previous frame)
		- Ending point:
			- EW: World coords: SW + integration of:
				- NPC's velocity
				- Floor's friction (only when "sticking" to the floor): f(M * A)
					- M = NPC's mass
					- A = acceleration experienced by triangle
						- Calculated as delta between previous SW and new world position of same barycentric coords
					- f(.) = non-linear switch: force only applied if it's less than a threshold
				- Floor's counter-gravity
					- Only if NPC is on a side of its triangle at beginning of frame
					- In the direction perpendicular to the triangle's side
						- So that we correctly apply it also when NPC is upside-down
				- Forces acting on NPC (gravity, etc.)
		- Algo for physics update of one NPC:
			- 0. If current triangle (guaranteed to be set) has been deleted, transition to free regime
				- Note: triangle deleted <=> spring deleted, so this is regardless of whether NPC is on spring or not
			- 1. F = {g & world forces, ext forces}
			- 2. If NPC on spring:
				- Calculate Fa == apparent force due to difference between (current) world position of NPC (SW) and current position of triangle's pos (World(SR))
				- F' = opposite of component of (F+Fa) perpendicular to spring (from inside of triangle)
				- F' += (non-linear) friction due to normal component of (F+Fa) above, tangential to spring
			- 3. Integrate (F + F') and of course NPC's velocity, calculating EW
			- 4. Perform ray tracing; if collision, move NPC and update velocity (bounce) as usual (i.e. with normal and tangential velocity responses)
		- Details on ray tracing: 
			- Perform ray tracing from SR to EW, in order to:
				- Determine exit & entry through all triangles in path
				- Eventually stop at a floor
			- Details:
				- Start in SR triangle == ST
				- Loop:
					- Calculate relative coords of EW in ST == E'R
					- If E'R is *within* ST:
						- We're done
					- Else:
						- Determine side of ST that SR->E'R path crossed
							- It's gotta be one and only one
						- Check if that side is floor; if it is: apply "collision" logic and stop
						- (if not floor) Find next triangle (triangle opposite that side)
						- If there's no triangle: enter "free regime" and stop
						- ST = this new triangle; continue loop
		- Details:
			- Barycentric coords, and intersection of segment with triangle:
				- https://math.stackexchange.com/questions/2382016/determine-if-a-line-segment-passes-through-a-triangle
			- Cartesian to Barycentric: https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates
			- More barycentric coords, and ray tracing w/C algo:
				- https://web.archive.org/web/20170517125238/http://www.cs.virginia.edu/~gfx/courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
			- Plucker coords, and intersection of segment with triangle:
				- https://members.loria.fr/SLazard/ARC-Visi3D/Pant-project/files/Line_Segment_Triangle.html
				- 2D: https://www.geogebra.org/m/aRMTsu62

- Rendering:
	- NPCs will have two sets of vertex attributes:
		- Static ones: contain static properties (colors, )
			- Only reloaded at e.g. NPC insertion/removal
		- Dynamics ones: contain world vertices, texture coords
	- TODO: do we need indices like ships?

Code
===========
Arch:
- One single NPCs container class owned and managed by World
- Render dispatched to individual ShipRenderContext's, as each ship has own Z world
	X Though we could have a NpcRenderContext which passes ship's Z in vertex buffers, but then there's the order/alpha problem; best if rendered by each ship individually

- TODOHERE:
	- Fix issue with tool & zoom
		- Tool works in world coordinates
			+ Picking returns PickedObject == <ObjectId, world offset>
				+ GameType
			- Tool keeps world offset and talks absolute coords with GameController
			- Also, stop doing offsets other than at MoveNpc(.)
			+ IGameController: already has coord tx methods
			- Update():
				- Replaces MouseMove: checks if new world coords != last and, if so, moves NPC
		- See if also Move tools need the same
	- Complete moving/placing
	- Shader: discard  when transparent
		- But only after testing with two connected components & e.g. flames - & inverse order of drawing
	- New spring getter: NpcSurfaceType
		+ GameType
		- ShipFactory: populate as "Floor" using IsHull for the time being (w/comment), @ point matrix
			- But split factory vs. effective, for doors
		- Then can do Npcs::IsSuitable
	- Update:
		- 


- Placing an NPC:
	- The user selects the "place NPC" tool at the same time as choosing the type and sub-type via menus
	- TODOHERE: 
	- Once the tool is selected, ToolController is notified via a dedicated API (which takes type/subtype)
		- With this call the tool is switched to the NPC-placing tool, but the old one is remembered so that once an NPC is placed, we can go back to the previous tool (unless SHIFT is pressed)	
	- Initialization of the tool makes a call into GameController::BeginHumanNpcPlacing(role, pos), and de-initialization calls GameController::EndNpcPlacing()
		- The NPCs class has a "special slot" for a single NPC being placed, initialized and removed with these two calls
		- Note: check leave window/enter window
	- Moving the tool: 
		- At movement, tool calls GameController::MoveNpcPlacing(pos) -> bool telling whether or not it's a good place (and whether or not there's still room for NPCs)
			- Npcs::MoveNpcPlacing: always moves
			- Placement check: either not in a triangle, or in a triangle with at least one side NON-floor
			- Tool remembers whether current position is OK for placement (storing in opt<position>, if set then ok else not)
		- Mouse down: only if that opt<position> is set, calls into GameController::AddHumanNpc(...)
			- Note: placing continues, even if all NPC slots used

- Removing an NPC:
	- We first find the triangle/ship (eventually none), then ask NPCs for closest to that -> NpcId
	- Tool highlights NPC at mouse move via Npcs::HighlightNpc(NpcId, true/false)

- Moving an NPC:
	- TODOHERE

Details:
- NPCs class:
	- Container of NPCs
	- Owned by World; accessed - when needed - by Ships via ParentWorld
	- Contains all NPCs from all ships
		- Organized internally by ship, so that updates - which require ship triangles, etc. - are optimized, and ships may easy access all their NPCs easily e.g. when doing interactions
			- For each ship there is a vector (e.g. std::vector<NPCState>), kept compact during removals and additions of NPCs
			- The vector of ships is also itself kept compact during removals and additions of ships
			- Separately, a "ship index" vector and a "NPC index" vector for each ship form a two-tier "index" for mapping stable ShipIDs and NPCIDs to elements in these buffers
				- Index also kept up-to-date at Ship and NPC addition/removal
				- The pair of these indices is the NPC's stable, globally-unique ID, unrelated to the position it occupies in NPC buffers
		- One single buffer per-physical quantity though, across all ships and NPCs, so that we do physics updates with one single pass
			- Buffer is pre-sized to max # of NPCs
			- Need same tricks as other physics buffers wrt additions/removals, e.g. zeroing coeffs so that update steps are essentially nop's
		- NPC struct:
			- Type: NpcKindType
			- Union of all kind-specific attributes
				- Note: many attributes will be common, hence we'll be saving room
	- AddShip(shipID)/RemoveShip(shipID)
	- TODOHERE: review dynamics of adding, considering that we can't drop in certain triangles:
		World::AddHumanNPC(..) -> ID
		- World finds ship by inverse Z order, using Ship.GetTriangles().GetTriangleContaining(.)			
			- If no triangle found, NPC is added with free regime, on last (topmost Z) ship
		- Then World calls NPCs::AddHumanNPC(.., ship const &, opt<triangle index>)	
	+ RemoveNPC(ID)

	- Update(Ship const &)
	- Upload(Ship const &, ShipRenderContext)
		- Invoked by World for each ship separately
		- Invokes ShipRenderContext::UploadNPC:
			- A TextureGroup enum - declared in RenderTypes like AntiMatterBomb is for example - is used to identify the "movement types" for rendering. An additional index provides the sub-frame. The whole coordinate is a TextureFrameId<NPC group>.
				- TODO: actually the enum might not have to be in RenderTypes; we could use a generic "state" enum in GameTypes which *also* serves as a groups enum
- Physical Interactions:
	- Wind: all ships, only in free regime
	- Ship-specific explosions: only of that ship, or free regime
	- Swirl, etc.: all ships, all regimes






- OLD:
- "Walkability"
	- A particle is either "walkable" or not
	- A spring is "walkable" only if both endpoints are "walkable"
		- "Walkabaility" of springs is maintained at destroy and repair
	- A specific "Paths" (or "FloorPlan") layer provides a bitmask indicating which particles are walkable and which are not
		- When the layer is absent, the bitmask is created automatically with the hullness of particles

- Walking:
	- A given walkable spring has effectively two sides, and thus we need to remember on which side we are
		- Example: we're walking on a spring, and then ship is rotated by 180 degrees: we need now to fall, rather than continue walking on the other side of the spring
	- An NPC then remembers:
		- Which spring it's walking on, and
		- Which of the two endpoints is at its *right* when the NPC is staring at us

- State machine(s):
	- Constrained regime:
		- Freefall state:
			! In this state an NPC is falling down a non-walkable spring
			- Do hole check to check for transition to Free regime
			- When mid-spring: slide along spring in the direction that is most aligned with gravity
			- When the NPC reaches an endpoint of the spring:
				- If the point is non-walkable:
					- Choose the next spring (by definition: non-walkable): 
						- The one most aligned with gravity
					- Keep falling (stay in this state)
				- Else (the point is walkable):
					- Transition to Landed state
		- Landed state:
			! Temporary state, exists for animation
			- Do hole check to check for transition to Free regime
			- TODOHERE: incorporate "remembering *right* endpoint of spring we're walking on" from here on
			- From here, after some time: choose a walking direction: "left" or "right", then transition to Walking_MakeNextChoice
				- TODO: see below if we actually can find next spring without having an incoming spring
		- Walking:
			! When an NPC is walking, it follows a predefined direction, either "left" or "right"
			- Do hole check to check for transition to Free regime
			- When mid-spring:
				- Calculate velocity:
					- TODO: resultant of constant WalkingVelocity in the direction of the walk with gravity (projected along spring) + friction
					- TODO: incorporate "remembering *right* endpoint of spring we're walking on" from here on
				- Move by velocity
			- When the NPC reaches an endpoint of the walkable spring: transition to Walking_MakeNextChoice state
		- Walking_MakeNextChoice:
			- Do hole check to check for transition to Free regime
			- Choose the next spring:
				! Could be the same as the incoming in case we're sliding
				- The first non-deleted walkable spring (first in CW direction if going R, else CCW if going L, from the incoming spring)
					- TODO: see if can do without having to remember incoming spring: redefine how we choose next spring knowing only the wanted direction
				- If it is in the walking direction, and if it is not too steep
					- Steepness check uses friction of walkabaility
			- If a choice can't be made: invert direction
				- Stay in this state so we still need to make a choice

	- Free regime:
		-
