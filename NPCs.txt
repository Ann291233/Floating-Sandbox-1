NPC Overview
===========

NPCs are of (at least) two types: humans, and furniture. Human NPCs have an AI and move on their own; furniture NPCs are simply static.


NPC Physics
===========

An NPC is represented by one (or more) particles, exactly like all the other particles in FS. The way the NPC particles move depends on the "regime" or "state" in which an NPC finds itself at the moment. There are two possible "regimes".

** Constrained Regime **
This is the initial regime, when the NPC is spawn. In this regime the NPC particle is constrained to move within triangles of the ship, and the particle's movement is the resultant of the NPC's own movement (e.g. walking), friction along "floor" sides of the triangles, counter-gravity generated by "floor" sides of the triangles, and any external forces (including gravity). As an example, when walking on an almost-flat horizontal side of a triangle, gravity has little effect and the NPC moves freely. As soon as the spring becomes too steep, however, gravity wins and the NPC "slides" down the spring.

In the Constrained Regime NPC's normally walk along the springs of the "Paths" layer, i.e. springs of the ship that are also present in the Paths layer. These springs make up the paths that NPC's walk along. However, NPCs may eventually lose their path, for example when at the end of a path or when the path becomes too steep. When this happens, they fall along the ship springs according to gravity, until they reach a path spring again.

An NPC remains in the constrained regime until it reaches a "hole" point, i.e. a point through which normally water would enter. When this happens, the NPC enters the "Free" regime.

** Free Regime **
In this regime NPC's do not follow paths, but rather move freely according to particle physics. They fall when in air or sink, rise, and float when in water. Once in this regime, the NPC stays in this regime.

This regime has a few sub-states controlling the actions and the rendering of the NPC, and a separate algorithm governs the transitions between these states. The states are:
- Floating: the NPC particle is stationary on the sea surface; the NPC might be rendered as asking for help with its arms and moving its legs to stay afloat.
- Sinking: the NPC particle is sinking towards the bottom of the sea; the NPC might be rendered as rotating with limbs moving in arbitrary directions.
- Rising: the NPC particle is underwater but rising towards the sea surface; the NPC might be rendered as swimming upwards.

NPC particles are made of one of few new "NPC" materials, for example "Human NPC", which simulates human mass and buoyancy when breathing, resulting in a particle that would normally *barely* float. If arbitrary transitions between the three states are required - e.g. a floating NPC should start sinking all of a sudden - these will be implemented by means of forces added onto the particles.

NPC Rendering
===========

The particle of a "Human" NPC is considered to be its feet. An additional particle - the head - is attached to the feet via a spring, and only used for rendering purposes. This allows for bending and angular momentum.
This additional particle's mechanical physics is updated at the same loop as the main particle's mechanical physics, but doesn't participate in anything else.
If the concept works fine, we can enhance it later with additional springs for limbs. We will begin with one single particle though.

The two particles define a simple elongated quad. This quad is then rendered with textures, from an atlas containing all NPC frames.
The texture groups' are the "movement types" (e.g. "walking", "falling", "swimming", etc.) (together with furniture NPC types, such as "table", etc.). Each movement type has 1 or more frames, numbered consecutively.

Color coding:
- TODO: https://www.reddit.com/r/gamedev/comments/3215xb/replacing_texture_colors_in_opengl/
- texture3d: 
	- Basics: https://stackoverflow.com/questions/20012676/glsl-change-specific-color-of-texture-to-another-color and https://www.reddit.com/r/opengl/comments/1x2rq1/how_can_i_replace_one_color_from_a_texture/
	- To create LUT table: http://kpulv.com/359/Dev_Log__Color_Grading_Shader/

Frame rules:
1. Frame size is 64x64
	Max 4096 frames
2. Try to maximize canvas usage. Ideally, for the "standing" frame, the feet touch the bottom edge, and the topmost pixel (above the head) touches to top edge
3. Each frame will have to be duplicated for man and woman appearances
4. We're going to use color coding. Basically, some of the colors in each frame will be changed at rendering time to allow for differently-colored uniforms for different roles.
	So for example we can have role-specific colors for the pants/skirts, jackets/shirts, and if we want, stripes on the arms and/or legs, and hats
	Like at https://www.reddit.com/r/gamedev/comments/3215xb/replacing_texture_colors_in_opengl/
4a. Background has to be full white (255, 255, 255)
	If we need actual white in the frame, we can use a slightly darker white
4b. (and this part I still have to think through completely, but we can start with this)
	You may use any colors you want, but these are special and will be replaced by role-specific colors
	medium red: 128, 0, 0: upper body (shirt/jacket)
	light red: 255, 0, 0: lower body (pants/shirt)
	medium green: 0, 128, 0: shoes
	light green: 0, 255, 0: hat
	medium blue: 0, 0, 128: unassigned at this moment (don't use)
	light blue: 0, 0, 255: unassigned at this moment (don't use)
5. Walking frames: 
5a. 3 frames (1: left leg ahead, 2: both legs vertical, 3: right leg ahead)
5b. The upper body vertical axis needs to be horizontally centered and needs to stay aligned vertically - basically, the animation needs to look fluid if you alternate the three frames always at the same position

Details
===========

- Type hierarchy:
	- NpcType:
		- Human
			- HumanNpcRoleType:
				- Passenger
				- ...
		- Furniture
			- FurnitureNpcType:
				- Table
				- ...

- In the constrained regime:
	- A particle always belongs to a triangle
		- And its world coords can be translated back and forth into barycentric coords wrt the triangle
		- As a special case, the particle may strictly belong to a *side* of that triangle, in which case we assume it's walking on it
			- We can store a "sticking" boolean to remember it's attached, though it's simply a special case of barycentric coords saying it's on a *side*
	- Core of the simulation of an NPC:
		- Starting point:
			- SW: World coords: current coords
			- SR: Relative coords: barycentric coords of SW in old "state of triangles" (which may just be stored at previous frame)
		- Ending point:
			- EW: World coords: SW + integration of:
				- NPC's velocity
				- Floor's friction (only when "sticking" to the floor): f(M * A)
					- M = NPC's mass
					- A = acceleration experienced by triangle
						- Calculated as delta between previous SW and new world position of same barycentric coords
					- f(.) = non-linear switch: force only applied if it's less than a threshold
				- Floor's counter-gravity
					- Only if NPC is on a side of its triangle at beginning of frame
					- In the direction perpendicular to the triangle's side
						- So that we correctly apply it also when NPC is upside-down
				- Forces acting on NPC (gravity, etc.)
		- Algo for physics update of one NPC:
			- Done at BaryLab
				- 0. If current triangle (guaranteed to be set) has been deleted, transition to free regime
					- Note: triangle deleted <=> spring deleted, so this is regardless of whether NPC is on spring or not
				- 1. F = {g & world forces, ext forces}
				- 2. Note: the below is apparently not needed if we take care of impact response when on edge (below); verify that we can take care of friction well in the edge code,
				     when we have no idea of relative movements
				     - If NPC on spring:
					- And: allow when in floor to move like ghost, so if NPC on spring _and_ not all springs of triangle are floor
					- Calculate Fa == apparent force due to difference between (current) world position of NPC (SW) and current position of triangle's pos (World(SR))
					- F' = opposite of component of (F+Fa) perpendicular to spring (from inside of triangle)
						- Note: only if normal is right direction wrt trajectory
					- F' += (non-linear) friction due to normal component of (F+Fa) above, tangential to spring
						- Static and kynetic friction:
							- http://www.epi-eng.com/mechanical_engineering_basics/force_and_friction.htm
							- https://www.motioncontroltips.com/why-is-static-friction-greater-than-kinetic-friction/#:~:text=Static%20friction%20is%20what%20keeps,once%20they%27re%20in%20motion.
							- https://openstax.org/books/university-physics-volume-1/pages/6-2-friction
								- The direction of friction is always opposite that of motion, parallel to the surface between objects, and perpendicular to the normal force.
				- 3. Integrate (F + F') and of course NPC's velocity, calculating EW
				- 3b. Reset ext forces
				- 4. Perform ray tracing; if collision, move NPC and update velocity (bounce) as usual (i.e. with normal and tangential velocity responses)
					- Impact forces: https://www.studysmarter.co.uk/explanations/physics/force/impact-forces/
				- Details on ray tracing: 
					- Perform ray tracing from SR to EW, in order to:
						- Determine exit & entry through all triangles in path
						- Eventually stop at a floor
					- Details:
						- Start in SR triangle == ST
						- Loop:
							- Calculate relative coords of EW in ST == E'R
							- If E'R is *within* ST:
								- We're done
							- Else:
								- Determine side of ST that SR->E'R path crossed
									- It's gotta be one and only one
								- Check if that side is floor; if it is: apply "collision" logic and stop
								- (if not floor) Find next triangle (triangle opposite that side)
								- If there's no triangle: enter "free regime" and stop
								- ST = this new triangle; continue loop
		- Details:
			- Barycentric coords, and intersection of segment with triangle:
				- https://math.stackexchange.com/questions/2382016/determine-if-a-line-segment-passes-through-a-triangle
			- Cartesian to Barycentric: https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates
			- More barycentric coords, and ray tracing w/C algo:
				- https://web.archive.org/web/20170517125238/http://www.cs.virginia.edu/~gfx/courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
			- Plucker coords, and intersection of segment with triangle:
				- https://members.loria.fr/SLazard/ARC-Visi3D/Pant-project/files/Line_Segment_Triangle.html
				- 2D: https://www.geogebra.org/m/aRMTsu62

- Human behavioral state machine(s):
	- Principles:
		- Most transitions happen with "convergence" of some quantity
			- Only the convergence rate is a state-specific parameter; the threshold for reaching a target is not (i.e. it's a global constant)
				- So that there's only one param per state controlling timing
	- States:
		+ State:KnockedOut
			! Does nothing
			+ Transitions out: 
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following applies for at least Tx: transition to Rising
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
					+ S particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
		= State:Rising
			! Tries to stand up (applying torque)
			+ Transitions out:
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following stops applying: transition to KnockedOut
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
				+ When MaintainAndCheckEquilibrium() returns false: transition to KnockedOut				
				+ When line from S to P is aligned with GravityDir: transition to Equilibrium
			- External out transitions:
				- Impact: transition to KnockedOut
					- UpdateStep() takes NpcState as well, and calls Npcs::OnHumanNpcImpact(NpcState, impact quantities) upon impact
						- OnHumanNpcImpact: switches on state
		+ MaintainAndCheckEquilibrium() -> bool:
			+ Does torque calculation and reaches/maintains equilibrium, but also checks if conditions to stay in equlibrium  apply; stops equlibrium (and returns false) if:
				+ HumanVector is outside of -alpha->alpha sector around vertical, with rotation velocity towards outside of sector
		+ Impart torque:
			+ With Particles::VoluntaryForces
				= Reset at state transitions
			+ Formula:
				+ Force perpendicular to human vector; magnitude depends on angle
				+ See why primary moves: is it because of spring being compressed?
					+ It's because at beginning each step stretches it, then the spring recoils to the point that the other endpoint needs to move
				+ Force can't be directional - or else it cancels gravity - not that it's important, but highlights un-soundness of approach
					+ Go full rotational spring
				+ See if can raise faster with less overshooting
		= State:Equilibrium
			! Stands up; continues to adjust alignment with torque
			+ Transitions out:
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following stops applying: transition to KnockedOut
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity
				+ When MaintainAndCheckEquilibrium() returns false: transition to KnockedOut
				+ When enough time has passed in this state: transition to Walking
			- External out transitions:
				- Impact: transition to KnockedOut
		= State:Walking
			! Walks; continues to adjust alignment with torque
			+ Transitions out:				
				+ When whole NPC becomes free: transition to FreeKnockedOut
				+ When the following stops applying: transition to KnockedOut
					+ P particle:
						+ On (at least one) floor edge (& in constrained state)
						+ Zero relative velocity (excld. walking)
				+ When MaintainAndCheckEquilibrium() returns false: transition to KnockedOut
			- External out transitions:
				- Impact: transition to KnockedOut
			+ Walking state machine:
				+ Impart displacement
					+ First, allow traj calculation to also pre-calculate final (absolute) velocity
						+ Traj calc state keeps it, "TargetAbsoluteVelocity"
						+ UpdateTrajState() returns it when completing w/out impact
							+ finalParticleState has velocity not as optional but as mandatory
								+ No more automatic vel calc'n at end of UpdateTrajState()
							+ Always provide target vel from within UpdateTrajState()
								+ Assert it matches a calculated one - when no impact has happened						
					+ Then: at traj calculation, superimpose raw walking displacement (calcd at HumanUpdate and stored in VoluntarySuperimposedDisplacement) to traj, without affecting velocity
					+ FIX: secondary trails primary
						+ @ TrajCalculation: when we incorporate walking displacement, if it's primary we save same vector as displacement of secondary
						+ At HumanNpcStateUpdate: clear also secondary displacement on transitions out
				

		+ Problem: while walking, difference in slope is giving us troubles:
			+ When moving from edge floor to edge floor with lower slope, we lose contact with edge
				+ And this happens because once we climb to other triangle, the trajectory end in bary coords does not lie anymore on edge
			+ When moving from edge floor to edge floor with higher slope, primary has impact and gains bounce velocity (because we check traj)
			+ Solution: might need to change how impact works, if walking reaching slope that it should try to climb causes noticeable impact
				+ We can solve it @ impact detection by checking slope first, and not causing impact bounce when slope is gentle - but still climbing over edge in order to "land" on slope
				+ Do rearc 

		= TODO: do we really want primary non-inertial do gain physical velocity when walking? Example: climbing up, gains however down velocity until this one overpasses walking
				- May be it's OK after all...
			- Also: BUG: impact of secondary when discounting walk vector results in anti-impact
			X Algo 1 for fix:
				! If result is opposite sign of phys, shouldn't gain phys but zero instead
					! If result is opposite sign of zero, should gain zero (this is now)
					! In other words: velocity gain should never be opposite of result (actual)
				! Generalization: velocity gain max should be:
					! Result > 0: max(phys, 0) // e.g. climbing up on \* : only gains > 0
					! Result < 0: min(phys, 0) // e.g. climbing up on */ : only gains < 0
				X Do:
					X Do new velocity calculation at 3 places (TODOHEREx):
						= 1: NonConstrained move-to-place: here we do with edgeDir
						= 2: Constrained move-to-place: here we do with absolute positions; velocity is:
							- Direction: of result (i.e. result_dir)
							- Magnitude: as above, with phys projected onto result_dir
							- TODOHERE: conflicts with torque!
						- 3: Bounce when calculating incident velocity - incident velocity must be same as in 1 and/or 2
					- Double-check passed walked total/planned vs primary/secondary
						- Primary: totalEdgeWalkedActual starts from zero and grows step-by-step
						- Secondary: totalEdgeWalkedActual is resultant from primary since the beginning, and immutable
			= Algo 2 for fix:
				! Add walk *displacement* calculated to *fill-in* (desired) walk vector
					! If (planned) physics is already more, then displacement is zero
					! The displacement then takes part in normal velocity calculations
					! This displacement is the one which, summed up, goes to secondary
				+ Plan:
					+ Undo other changes (surgically)
					+ Main loop:
						+ Primary: new plannedWalk calculation
							+ if walk in same direction as edgeDir:
								- plannedWalkVector = edgeDir * max(walk desired along edge - planned phys along edge, 0)
								OR - so that we don't walk on too steep:
								- plannedWalkVector = edgeDir * min(max(walk desired along edge - planned phys along edge, 0), walk desired along edge)
							+ else:
								- ...
							+ actualWalk is then added to total (as now)
							+ plannedWalk is added to plannedPhys to make plannedTotal (as now)
						+ Secondary:
							+ actualWalk taken from primary (as now)
					+ All three velocity calculations:
						+ Back to basics: just take whole, real displacement - hear nothing of "walked"
							+ Remove "walked" and "phys/total" args
								+ Unless phys/total is used for assert - keep "total" for that
					+ Problem fix
						+ Disable storing equilibrium torque
						+ Disable secondary displacement
						X At phys force calc: if NPC is walking and this is secondary, calc additional force - on top of calcd - needed to bring sec'ry on top of primary
							X Do in "distance" space
						+ Do normal torque here
				+ Things to fix:
					+ Bump with vertical wall: going back (when floor is sloped down-right) is not constrained anymore because of |\*| <--
						! Which means we do another bump (albeit negligible but still against direction, dot is 0.06) and thus another flip
						+ Option 1: at main loop: if we are at a cuspid, we shouldn't be too hasty in deciding non-inertial vs inertial; should move out of cuspid first
							+ Almost same loop as in NonInertial: until in triangle or becomes free or hits floor
					+ Walks on too steep of a wall
						+ Happens because friction zeroes out G
						X This should be fixed with less friction
						+ Two-sided fix:
							+ Clip and squash dot product at actual walk plan calculation ("apply G resistance")
							+ MaintainWalk: flip if too long at V opposite of W
								+ 1: Check condition (V opposite of W); if true: TargetFlipDecision=1.0; else: Target&CurrentFlipDecision=0.0
								+ 2: Advance CurrentFlipDecision towards TargetFlipDecision
								+ 3: If CurrentFlipDecision > 0.95: flip, & set Target&CurrentFlipDecision=0.0
								+ Replaces having to flip at well detection? Verify it can, both sides
									+ Turn off first for test
									+ Verify it replaces it
								+ Set FlipDecisions to zero at bounce flip
								+ HumanFlip(isImmediate)
									+ Called by both places at which we flip
								+ Later: test with a margin above @ 1 so that we also flip when yes V in same direction as W but not quite there
									+ FIX: looping around 0.0/~-0.0
					+ See if can lose equilibrium when secondary too skewed but not too much relative opposite vel because of secondary being blocked
						+ In equilibrium only, CheckEq breaks Eq at lower threshold - even when relative V is same sign but quite low
					+ Slow when walking downhill: because of "gravity resistance", which shouldn't apply when downhill (only uphill)
						+ Do better curve w/Smoothstep
						+ "GravityAllowance"
				+ Higher static and kinetic friction
					X Google V for change from S to K
				+ Lower walking speed
				+ Fix torque w/mesh velocity
					+ Is it that at torque calc we see primary already moved - by a lot - while secondary hasn't moved yet?
				+ Video
					+ Code for script
					+ Fix little jump
						+ Add tolerance
						+ Don't invoke walk update when not on edge - w/comment on not needing to silence walk mag as we don't apply walking when inertial (i.e. when not on edge)
						+ Test flying off
				+ "Jump tolerance" also for other two states
					+ 1. Thus regardless of state
						+ HumanState.CurrentEquilibriumSoftTerminationDecision
							+ Reset also at transitions to Rising & Equilibrium
						+ Do not start walking if not on edge
					+ Test w/walk & ball
					+ Commit before next one
					+ 2. Do not apply torque while not on edge
						+ Go back to having NpcParticle float buffer (w/1.0 or 0.0) for torque
						+ reset() buffer before NPC loop
							+ w/note for prelim forces
						+ Set it from CheckAndMaintainEq(...isOnEdge...)
							+ Simply iff on edge
						X Make sure we zero it when leaving any of the states
						+ Use at torque calculation
				+ Flip also when *secondary* bounces
				+ Sea level:
					+ Param, UI
					+ World forces: if free
						+ Find sweet spot for thickness of interface/buoying at shoulders
							+ Offset for sea level to account for head
						+ Forces rearc:
							+ NpcParticle has PreliminaryForces
								+ All those we can calc @ beginning
							+ Npcs::CalculatePreliminaryForces()
								+ Takes care or cleaning - if needed
							+ Npcs::CalculateDefinitiveForces()
					+ Material buoyancy
					+ Rendering
				= Cleanups if ok:
					+ CalculatePhysForces
					+ Old torque 
						+ And "voluntary" buffer for torque force?
					+ Do we still need "voluntary" displacement of secondary?
					- Make triangle-finding (rotate through vertices/cuspids) a function
						- Return: <do_stop> (note: no need to return traveled - it never moves)
						- Integrate it with "look-ahead for planning" functionality that we need
					- "TODO: get rid of this" (local triangle index)
				- When finding triangles (e.g. opposite triangle, but also initializations), check if triangle is deleted
				- Test:
					- Flying off
						- Primary into inertial
						- Secondary into inertial
						- Primary into free
						- Secondary into free
					- Starting at vertex
					- With mesh moving

		- See why head stays above floor at WalkingTests mesh

		- Animation:
			= Store current edge
				! Needed for foot points
				+ ConstrainedState::CurrentVirtualEdge // not really valid when at cuspids
				+ Set after call to NonInertial
				+ Render it (dark red)
				- FIX: when trying to walk up, virt edge is the vertical one
					- TODO: Vertical is really the body
				- Fix rendering: do not render all edges but just triangles'
			+ Move behavior update: update behavior before animation, after physics
				+ FIX: it's broken
					+ Because we lose EquilibriumTorque, move reset afterwards
				+ Test
			+ Shader
				+ Basic
				+ Do ellipses
			- Store total travelled (displaced)
				- New HumanState member: float TotalEdgeTraveledWhileWalking
				- Reset it when entering Walking state
				- Also in inertial mode, as we now might be walking
					- But check this only later
			= Move points (new Human members) @ Update
				! Each state is responsible for it
				- Walking:
					- 1. Formula calculating angle, as rotation of legs
						- Angle members, and points as well (points will be useful for more calc's later, see below)
							! We want angles so that we can smooth-merge sequences
							- CurrentLegRightAngle, no need for Target
							- AnimationUpdate calc's targets and smooths currents to it
						- Formula:
							- A: atan-based along horiz (horiz because human is vertical)
						- Calc points: trivial
					- 2. Constrain points to be along current edge's direction
						- Direction dictated by angle, it's only *length* of leg that changes to stop at current edge
							- TODO for formula
		- Code rearcs:
			- Rearc source files in NPC folder
			- NpcDatabase
				- 
				- TODOHERE
			- NpcTypes: all struct def's
				- HumanNpcState:
					- Union for behavior states
						- Unions' cctors are used to reset state
			- Various static helpers (e.g. is IsFloorToParticle, ...)

		= Add velocity damp
			= And slider
			- Test
		= Impacts:
			+ At each impact, call OnImpact(...particle..., ...impact quantities...)
			= OnImpact: if human, check state machine and do following transitions:
				+ If walking and impact V (velocity of particle along normal) is in direction of walking:
					+ Flip direction
				- TODOHERE - and see above - for other state transitions

		- State:FreeKnockedOut:
			! Does nothing
			- TODOHERE

	- Other walking features:
		- See if can detect that will hit a wall/well by projecting forward primary particle along triangle edge; if will hit, turn around
		- "staircases": floors can be marked as "stairs", and that is used in two places:
			- Bounce detection: when walking, no bounce regardless of slope (do continuation case)
				- Only when we're walking
			- Walk vector flattening: forcibly extend walk along edge, even if exactly orthogonal
			- Auto-build: when two three consecutive edges wind up to 360 degrees
			- TODO: the above is actually option 2; option 1 would be to change tessellation (redundant triangle choice) when the spring being lost is the only floor
				- Test if FS is ok with it:
					- Frontiers
					- Anything else?
				- Test if BaryLab's triangle navigation algo's are ok with it
		- "manholes"
			- Floor info is on Triangle, not on Spring

- Rendering:
	- NPCs will have two sets of vertex attributes:
		- Static ones: contain static properties (colors, )
			- Only reloaded at e.g. NPC insertion/removal
		- Dynamics ones: contain world vertices, texture coords (because these are atlas coords and thus change between frames)
	- TODO: do we need indices like ships? TODO: what indices?
	- NpcType needs an associated NpcOrientation, because the way a quad is laid out around the particles for a human is different than that of a table
		- Uhm: after all a table is not that simple - think of flipping it

- Physical Interactions:
	- Lights: second pass of lighting algorith with all NPC particles, for each ship
		- Adding to NPC particles' _light_ buffer
	- Wind: all ships, only in free regime
	- Ship-specific explosions: only of that ship, or free regime
	- Swirl, etc.: all ships, all regimes
	- Move tool:
		- While MoveAll may be used to move everything, Move (component) only moves mesh, thus subjecting NPCs to apparent forces!


- Dipole:
	- Attempt 1:
		- Normal physics: calc spring forces first (in new particle's buffer) and include those forces when calculating trajectory
		- However, when on an edge, friction might get in the way of reunification of the particles, hence: attempt 2
	- Attempt 2:
		- If both not on edge: normal physics: calc spring forces first (in new particle's buffer) and include those forces when calculating (non-edge) trajectory
		- Else:
			- Each particle for which other is on edge: after calculating flattened traj which includes friction and all, calc how much extra movement is needed to reach rest length,
			  and add particle's portion of that to traj (half or whole, depending on whether both are on edge or only one)
				- The important part here is that this happens _after_ friction

	- Misc OLD:
	- Try:
		- Before all particle's state updates, we force positions for dipoles too far apart or too close to go back into a tolerance, then we allow spring forces to occur
			- We then need to recalc bary coords of both - but according to the old mesh positions - HOW?

- Floorplan layer:
	- A specific "FloorPlan" layer provides a bitmask indicating particles' (and thus, springs') floorness
		- In the future, also "floor areas"
	- When the layer is absent, the layer is created automatically with the hullness of particles

- NPCs class:
	- Container of NPCs
	- Owned by World; accessed - when needed - by Ships via ParentWorld
	- Contains all NPCs from all ships
		- Organized internally by ship, so that updates - which require ship triangles, etc. - are optimized, and ships may easy access all their NPCs easily e.g. when doing interactions
			- For each ship there is a vector (e.g. std::vector<NPCState>), kept compact during removals and additions of NPCs
			- The vector of ships is also itself kept compact during removals and additions of ships
			- Separately, a "ship index" vector and a "NPC index" vector for each ship form a two-tier "index" for mapping stable ShipIDs and NPCIDs to elements in these buffers
				- Index also kept up-to-date at Ship and NPC addition/removal
				- The pair of these indices is the NPC's stable, globally-unique ID, unrelated to the position it occupies in NPC buffers
		- One single buffer per-physical quantity though, across all ships and NPCs, so that we do physics updates with one single pass
			- Buffer is pre-sized to max # of NPCs
			- Need same tricks as other physics buffers wrt additions/removals, e.g. zeroing coeffs so that update steps are essentially nop's
		- NPC struct:
			- Type: NpcKindType
			- Union of all kind-specific attributes
				- Note: many attributes will be common, hence we'll be saving room
			- type: NpcParticleState
				- ElementIndex ParticleIndex (index in NpcParticles)
				- opt<ConstrainedStateType> ConstrainedState
					- TriangleElementIndex
					- BaryCoords
					- opt<OnFloorStateType> OnFloorState
						- EdgeOrdinal
						- SimulationTime startTime - TODO: dynamics of when reset
			- NpcParticleStateType PrimaryParticleState (i.e. feet)
			- opt<NpcParticleStateType> SecondaryParticleState (i.e. head)
	- Update(Ship const &)
	- Upload(Ship const &, ShipRenderContext)
		- Invoked by World for each ship separately
		- Invokes ShipRenderContext::UploadNPC:
			- A TextureGroup enum - declared in RenderTypes like AntiMatterBomb is for example - is used to identify the "movement types" for rendering. An additional index provides the sub-frame. The whole coordinate is a TextureFrameId<NPC group>.
				- TODO: actually the enum might not have to be in RenderTypes; we could use a generic "state" enum in GameTypes which *also* serves as a groups enum

Arch
===========
- One single NPCs container class owned and managed by World
- Render dispatched to individual ShipRenderContext's, as each ship has own Z world
	X Though we could have a NpcRenderContext which passes ship's Z in vertex buffers, but then there's the order/alpha problem; best if rendered by each ship individually

Impl:
===========
TODOHERE
- New spring getter: NpcSurfaceType
	+ GameType
	- ShipFactory: populate as "Floor" using IsHull for the time being (w/comment), @ point matrix
		- See Floorplan Layer below (*)
		- @Springs: split factory vs. effective, for doors
	- Then can do Npcs::IsSuitable
- Shader: 
	- Copy BaryLab shader
	- Discard  when transparent
		- But only after testing with two connected components - & inverse order of drawing; should bug out when near NPC is drawn before far NPC and they are on top of each other
			- Requires following their triangle
- Make sure triangle destruction is forwarded to NPCs
	- Any constrained NPC on a destroyed triangle becomes free

